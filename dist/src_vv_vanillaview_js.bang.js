"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkbang_html"] = globalThis["webpackChunkbang_html"] || []).push([["src_vv_vanillaview_js"],{

/***/ "./src/vv/common.js":
/*!**************************!*\
  !*** ./src/vv/common.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CODE\": () => (/* binding */ CODE)\n/* harmony export */ });\n// common for all r submodules\n  const CODE              = ''+Math.random();\n\n\n\n//# sourceURL=webpack://bang.html/./src/vv/common.js?");

/***/ }),

/***/ "./src/vv/t.js":
/*!*********************!*\
  !*** ./src/vv/t.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BROWSER_SIDE\": () => (/* binding */ BROWSER_SIDE),\n/* harmony export */   \"T\": () => (/* binding */ T)\n/* harmony export */ });\n\n  const BROWSER_SIDE      = (() => {try{ return self.DOMParser && true; } catch(e) { return false; }})();\n\n  const BuiltIns = [\n    Symbol, Boolean, Number, String, Object, Set, Map, WeakMap, WeakSet,\n    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,\n    Int8Array, Int16Array, Int32Array, \n    Uint8ClampedArray, \n    ...(BROWSER_SIDE ? [\n      Node,NodeList,Element,HTMLElement, Blob, ArrayBuffer,\n      FileList, Text, HTMLDocument, Document, DocumentFragment,\n      Error, File, Event, EventTarget, URL\n    /* eslint-disable no-undef */\n    ] : [ Buffer ])\n    /* eslint-enable no-undef */\n  ]\n\n  const DEBUG = false;\n  const SEALED_DEFAULT = true;\n  const isNone = instance => instance == null || instance == undefined;\n\n  const typeCache = new Map();\n\n  T.def = def;\n  T.check = check;\n  T.sub = sub;\n  T.verify = verify;\n  T.validate = validate;\n  T.partialMatch = partialMatch;\n  T.defEnum = defEnum;\n  T.defSub = defSub;\n  T.defTuple = defTuple;\n  T.defCollection = defCollection;\n  T.defOr = defOr;\n  T.option = option;\n  T.defOption = defOption;\n  T.maybe = maybe;\n  T.guard = guard;\n  T.errors = errors;\n\n  // debug\n  if ( DEBUG ) {\n    self.T = T;\n    self.typeCache = typeCache;\n  }\n\n  T[Symbol.for('jtype-system.typeCache')] = typeCache;\n\n  defineSpecials();\n  mapBuiltins();\n\n  function T(parts, ...vals) {\n    const cooked = vals.reduce((prev,cur,i) => prev+cur+parts[i+1], parts[0]);\n    const typeName = cooked;\n    if ( !typeCache.has(typeName) ) throw new TypeError(`Cannot use type ${typeName} before it is defined.`);\n    return typeCache.get(typeName).type;\n  }\n\n  function partialMatch(type, instance) {\n    return validate(type, instance, {partial:true});\n  }\n\n  function validate(type, instance, {partial: partial = false} = {}) {\n    guardType(type);\n    guardExists(type);\n    const typeName = type.name;\n\n    const {spec,kind,help,verify,verifiers,sealed} = typeCache.get(typeName);\n\n    const specKeyPaths = spec ? allKeyPaths(spec).sort() : [];\n    const specKeyPathSet = new Set(specKeyPaths);\n\n    const bigErrors = [];\n\n    switch(kind) {\n      case \"def\": {\n        let allValid = true;\n        if ( spec ) {\n          const keyPaths = partial ? allKeyPaths(instance, specKeyPathSet) : specKeyPaths;\n          allValid = !isNone(instance) && keyPaths.every(kp => {\n            // Allow lookup errors if the type match for the key path can include None\n\n            const {resolved, errors:lookupErrors} = lookup(instance,kp,() => checkTypeMatch(lookup(spec,kp).resolved, T`None`));\n            bigErrors.push(...lookupErrors);\n\n            if ( lookupErrors.length ) return false;\n\n            const keyType = lookup(spec,kp).resolved;\n            if ( !keyType || !(keyType instanceof Type) ) {\n              bigErrors.push({\n                error: `Key path '${kp}' is not present in the spec for type '${typeName}'`\n              });\n              return false;\n            }\n\n            const {valid, errors: validationErrors} = validate(keyType, resolved);\n            bigErrors.push(...validationErrors);\n\n            return valid;\n          });\n        }\n        let verified = true;\n        if ( partial && ! spec && !!verify ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for types that` + \n            ` only use a verify function but have no spec`);\n        } else if ( verify ) {\n          try {\n            verified = verify(instance);\n            if ( ! verified ) {\n              if ( verifiers ) {\n                throw {\n                  error:`Type ${typeName} value '${JSON.stringify(instance)}' violated at least 1 verify function in:\\n${\n                    verifiers.map(f => '\\t'+(f.help||'') + ' ('+f.verify.toString()+')').join('\\n')\n                  }`\n                };\n              } else if ( type.isSumType ) {\n                throw {\n                  error: `Value '${JSON.stringify(instance)}' did not match any of: ${[...type.types.keys()].map(t => t.name)}`,\n                  verify, verifiers\n                }\n              } else {\n                let helpMsg = '';\n                if ( help ) {\n                  helpMsg = `Help: ${help}. `;\n                }\n                throw {error:`${helpMsg}Type ${typeName} Value '${JSON.stringify(instance)}' violated verify function in: ${verify.toString()}`};\n              }\n            }\n          } catch(e) {\n            bigErrors.push(e);\n            verified = false;\n          }\n        }\n        let sealValid = true;\n        if ( !!sealed && !! spec ) {\n          const type_key_paths = specKeyPaths;\n          const all_key_paths = allKeyPaths(instance, specKeyPathSet).sort();\n          sealValid  = all_key_paths.join(',') == type_key_paths.join(',');\n          if ( ! sealValid ) {\n            if ( all_key_paths.length < type_key_paths.length ) {\n              sealValid = true;\n            } else {\n              const errorKeys = [];\n              const tkp = new Set(type_key_paths); \n              for( const k of all_key_paths ) {\n                if ( ! tkp.has(k) ) {\n                  errorKeys.push({\n                    error: `Key path '${k}' is not in the spec for type ${typeName}`\n                  });\n                }\n              }\n              if ( errorKeys.length ) {\n                bigErrors.push(...errorKeys);\n              }\n            }\n          }\n        }\n        return {valid: allValid && verified && sealValid, errors: bigErrors, partial}\n      } case \"defCollection\": {\n        const {valid:containerValid, errors:containerErrors} = validate(spec.container, instance);\n        let membersValid = true;\n        let verified = true;\n\n        bigErrors.push(...containerErrors);\n        if ( partial ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for Collection types`);\n        } else {\n          if ( containerValid ) {\n             membersValid= [...instance].every(member => {\n              const {valid, errors} = validate(spec.member, member);\n              bigErrors.push(...errors);\n              return valid;\n            });\n          }\n          if ( verify ) {\n            try {\n              verified = verify(instance);\n            } catch(e) {\n              bigErrors.push(e);\n              verified = false;\n            }\n          }\n        }\n          \n        return {valid:containerValid && membersValid && verified, errors:bigErrors};\n      } default: {\n        throw new TypeError(`Checking for type kind ${kind} is not yet implemented.`);\n      }\n    }\n  }\n\n  function check(...args) {\n    return validate(...args).valid;\n  }\n\n  function lookup(obj, keyPath, canBeNone) {\n    if ( isNone(obj) ) throw new TypeError(`Lookup requires a non-unset object.`);\n\n    if ( !keyPath ) throw new TypeError(`keyPath must not be empty`);\n\n\n    const keys = keyPath.split(/\\./g);\n    const pathComplete = [];\n    const errors = [];\n\n    let resolved = obj;\n\n    while(keys.length) {\n      const nextKey = keys.shift();\n      resolved = resolved[nextKey];\n      pathComplete.push(nextKey);\n      if ( (resolved === null || resolved === undefined) ) {\n        if ( keys.length ) {\n          errors.push({\n            error: \n              `Lookup on key path '${keyPath}' failed at '` + \n              pathComplete.join('.') +\n              `' when ${resolved} was found at '${nextKey}'.` \n          });\n        } else if ( !!canBeNone && canBeNone() ) {\n          resolved = undefined;\n        } else {\n          errors.push({\n            error: \n              `Resolution on key path '${keyPath}' failed` + \n              `when ${resolved} was found at '${nextKey}' and the Type of this` +\n              `key's value cannot be None.`\n          });\n        }\n        break;\n      }\n    }\n    return {resolved,errors};\n  }\n\n  function checkTypeMatch(typeA, typeB) {\n    guardType(typeA);\n    guardExists(typeA);\n    guardType(typeB);\n    guardExists(typeB);\n\n    if ( typeA === typeB ) {\n      return true;\n    } else if ( typeA.isSumType && typeA.types.has(typeB) ) {\n      return true;\n    } else if ( typeB.isSumType && typeB.types.has(typeA) ) {\n      return true;\n    } else if ( typeA.name.startsWith('?') && typeB == T`None` ) {\n      return true;\n    } else if ( typeB.name.startsWith('?') && typeA == T`None` ) {\n      return true;\n    }\n\n    if ( typeA.name.startsWith('>') || typeB.name.startsWith('>') ) {\n      console.error(new Error(`Check type match has not been implemented for derived//sub types yet.`));\n    }\n\n    return false;\n  }\n\n  function option(type) {\n    return T`?${type.name}`;\n  }\n\n  function sub(type) {\n    return T`>${type.name}`;\n  }\n\n  function defSub(type, spec, {verify: verify = undefined, help:help = ''} = {}, name = '') {\n    guardType(type);\n    guardExists(type);\n\n    let verifiers;\n\n    if ( ! verify ) {\n      verify = () => true;\n    } \n\n    if ( type.native ) {\n      verifiers = [ {help,verify} ];\n      verify = i => i instanceof type.native;\n      const helpMsg = `Needs to be of type ${type.native.name}. ${help||''}`;\n      verifiers.push({help:helpMsg,verify});\n    }\n\n    const newType = def(`${name}>${type.name}`, spec, {verify,help, verifiers});\n    return newType;\n  }\n\n  function defEnum(name, ...values) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n    \n    const valueSet = new Set(values);\n    const verify = i => valueSet.has(i);\n    const help = `Value of Enum type ${name} must be one of ${values.join(',')}`;\n\n    return def(name, null, {verify,help});\n  }\n\n  function exists(name) {\n    return typeCache.has(name);\n  }\n\n  function guardRedefinition(name) {\n    if ( exists(name) ) throw new TypeError(`Type ${name} cannot be redefined.`);\n  }\n\n  function allKeyPaths(o, specKeyPaths) {\n    const isTypeSpec = ! specKeyPaths;\n    const keyPaths = new Set();\n    return recurseObject(o, keyPaths, '');\n\n    function recurseObject(o, keyPathSet, lastLevel = '') {\n      const levelKeys = Object.getOwnPropertyNames(o); \n      const keyPaths = levelKeys\n        .map(k => lastLevel + (lastLevel.length ? '.' : '') + k)\n      levelKeys.forEach((k,i) => {\n        const v = o[k];\n        if ( isTypeSpec ) {\n          if ( v instanceof Type ) {\n            keyPathSet.add(keyPaths[i]);\n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              DEBUG && console.warn({o,v,keyPathSet, lastLevel});\n              throw new TypeError(`We don't support Types that use Arrays as structure, just yet.`); \n            }\n          } else {\n            throw new TypeError(`Spec cannot contain leaf values that are not valid Types`);\n          }\n        } else {\n          if ( specKeyPaths.has(keyPaths[i]) ) {\n            keyPathSet.add(keyPaths[i]); \n          } else if ( typeof v == \"object\" ) {\n            if ( k === '_self' ) {\n              //recurseObject({}, keyPathSet, keyPaths[i]);\n            } else if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              v.forEach((item,index) => recurseObject(item, keyPathSet, keyPaths[i] + '.' + index));\n              //throw new TypeError(`We don't support Instances that use Arrays as structure, just yet.`); \n            }\n          } else {\n            //console.warn(\"Spec has no such key\",  keyPaths[i]);\n            keyPathSet.add(keyPaths[i]);\n          }\n        }\n      });\n      return [...keyPathSet];\n    }\n  }\n\n  function defOption(type) {\n    guardType(type);\n    const typeName = type.name;\n    return T.def(`?${typeName}`, null, {verify: i => isUnset(i) || T.check(type,i)});\n  }\n\n  function maybe(type) {\n    try {\n      return defOption(type);\n    } catch(e) {\n      // console.log(`Option Type ${type.name} already declared.`, e);\n    }\n    return T`?${type.name}`;\n  }\n\n  function verify(...args) { return check(...args); }\n\n  function defCollection(name, {container, member}, {sealed: sealed = SEALED_DEFAULT, verify: verify = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !container || !member ) throw new TypeError(`Type must be specified.`);\n    guardRedefinition(name);\n\n    const kind = 'defCollection';\n    const t = new Type(name);\n    const spec = {kind, spec: { container, member}, verify, sealed, type: t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function defTuple(name, {pattern}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !pattern ) throw new TypeError(`Type must be specified.`);\n    const kind = 'def';\n    const specObj = {};\n    pattern.forEach((type,key) => specObj[key] = type);\n    const t = new Type(name);\n    const spec = {kind, spec: specObj, type:t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function Type(name, mods = {}) {\n    if ( ! new.target ) throw new TypeError(`Type with new only.`);\n    Object.defineProperty(this,'name', {get: () => name});\n    this.typeName = name;\n\n    if ( mods.types ) {\n      const {types} = mods;\n      const typeSet = new Set(types);\n      Object.defineProperty(this,'isSumType', {get: () => true});\n      Object.defineProperty(this,'types', {get: () => typeSet});\n    }\n\n    if ( mods.native ) {\n      const {native} = mods;\n      Object.defineProperty(this,'native', {get: () => native});\n    }\n  }\n\n  Type.prototype.toString = function () {\n    return `${this.typeName} Type`;\n  };\n\n  function def(name, spec, {help:help = '', verify:verify = undefined, sealed:sealed = undefined, types:types = undefined, verifiers:verifiers = undefined, native:native = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n\n    if ( name.startsWith('?') ) {\n      if ( spec ) {\n        throw new TypeError(`Option type can not have a spec.`);\n      } \n\n      if ( ! verify(null) ) {\n        throw new TypeError(`Option type must be OK to be unset.`);\n      }\n    }\n\n    const kind = 'def';\n    if ( sealed === undefined ) {\n      sealed = true;\n    }\n    const t = new Type(name, {types, native});\n    const cache = {spec,kind,help,verify,verifiers,sealed,types,native,type:t};\n    typeCache.set(name, cache);\n    return t;\n  }\n\n  function defOr(name, ...types) {\n    return T.def(name, null, {types, verify: i => types.some(t => check(t,i))});\n  }\n\n  function guard(type, instance) {\n    guardType(type);\n    guardExists(type);\n    const {valid, errors} = validate(type, instance);\n    if ( ! valid ) throw new TypeError(`Type ${type} requested, but item is not of that type: ${errors.join(', ')}`);\n  }\n\n  function guardType(t) {\n    //console.log(t);\n    if ( !(t instanceof Type) ) throw new TypeError(`Type must be a valid Type object.`);\n  }\n\n  function guardExists(t) {\n    const name = originalName(t);\n    if ( ! exists(name) ) throw new TypeError(`Type must exist. Type ${name} has not been defined.`);\n  }\n\n  function errors(...args) {\n    return validate(...args).errors;\n  }\n\n  function mapBuiltins() {\n    BuiltIns.forEach(t => def(originalName(t), null, {native: t, verify: i => originalName(i.constructor) === originalName(t)}));  \n    BuiltIns.forEach(t => defSub(T`${originalName(t)}`));  \n  }\n\n  function defineSpecials() {\n    T.def(`Any`, null, {verify: () => true});\n    T.def(`Some`, null, {verify: i => !isUnset(i)});\n    T.def(`None`, null, {verify: i => isUnset(i)});\n    T.def(`Function`, null, {verify: i => i instanceof Function});\n    T.def(`Integer`, null, {verify: i => Number.isInteger(i)});\n    T.def(`Array`, null, {verify: i => Array.isArray(i)});\n    T.def(`Iterable`, null, {verify: i => i[Symbol.iterator] instanceof Function});\n  }\n\n  function isUnset(i) {\n    return i === null || i === undefined;\n  }\n\n  function originalName(t) {\n    if (!!t && t.name) {\n      return t.name;\n    } \n    const oName = Object.prototype.toString.call(t).replace(/\\[object |\\]/g, '');\n    if ( oName.endsWith('Constructor') ) {\n      return oName.replace(/Constructor$/,'');\n    }\n    return oName;\n  }\n\n\n\n//# sourceURL=webpack://bang.html/./src/vv/t.js?");

/***/ }),

/***/ "./src/vv/types.js":
/*!*************************!*\
  !*** ./src/vv/types.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"TKey\": () => (/* binding */ TKey),\n/* harmony export */   \"THandlers\": () => (/* binding */ THandlers),\n/* harmony export */   \"TFuncArray\": () => (/* binding */ TFuncArray),\n/* harmony export */   \"TEmptyArray\": () => (/* binding */ TEmptyArray),\n/* harmony export */   \"TMarkupObject\": () => (/* binding */ TMarkupObject),\n/* harmony export */   \"TMarkupAttrObject\": () => (/* binding */ TMarkupAttrObject),\n/* harmony export */   \"TVanillaViewLikeObject\": () => (/* binding */ TVanillaViewLikeObject),\n/* harmony export */   \"TVanillaViewObject\": () => (/* binding */ TVanillaViewObject),\n/* harmony export */   \"TBangObject\": () => (/* binding */ TBangObject),\n/* harmony export */   \"TComponent\": () => (/* binding */ TComponent),\n/* harmony export */   \"TVanillaViewArray\": () => (/* binding */ TVanillaViewArray),\n/* harmony export */   \"TSVanillaViewObject\": () => (/* binding */ TSVanillaViewObject),\n/* harmony export */   \"TSVanillaViewArray\": () => (/* binding */ TSVanillaViewArray),\n/* harmony export */   \"BS\": () => (/* binding */ BS),\n/* harmony export */   \"SSR\": () => (/* binding */ SSR),\n/* harmony export */   \"Types\": () => (/* binding */ Types)\n/* harmony export */ });\n/* harmony import */ var _t_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./t.js */ \"./src/vv/t.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"./src/vv/common.js\");\n// types\n  \n  \n\n  // T\n\n    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_t_js__WEBPACK_IMPORTED_MODULE_0__.T);\n\n  // Both SSR and Browser\n\n    _t_js__WEBPACK_IMPORTED_MODULE_0__.T.defOr('KeyValue', _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`, _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Number`);\n\n    const TKey = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('Key', {\n      key: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`KeyValue`\n    });\n\n    const THandlers = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('Handlers', null, {verify: i => {\n      const validObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.check(_t_js__WEBPACK_IMPORTED_MODULE_0__.T`Object`, i);\n\n      if ( ! validObject ) return false;\n\n      const eventNames = Object.keys(i);\n      const handlerFuncs = Object.values(i);\n      const validNames = eventNames.every(name => _t_js__WEBPACK_IMPORTED_MODULE_0__.T.check(_t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`, name));\n      const validFuncs = handlerFuncs.every(func => _t_js__WEBPACK_IMPORTED_MODULE_0__.T.check(_t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`, func));\n      const valid = validNames && validFuncs;\n\n      return valid;\n    }});\n\n    const TFuncArray = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.defCollection('FuncArray', {\n      container: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      member: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`\n    });\n\n    const TEmptyArray = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('EmptyArray', null, {verify: i => Array.isArray(i) && i.length == 0});\n\n    const TMarkupObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('MarkupObject', {\n      type: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      code: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      nodes: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      externals: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n    }, {verify: v => v.type == 'MarkupObject' && v.code == _common_js__WEBPACK_IMPORTED_MODULE_1__.CODE});\n\n    const TMarkupAttrObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('MarkupAttrObject', {\n      type: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      code: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      str: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`\n    }, {verify: v => v.type == 'MarkupAttrObject' && v.code == _common_js__WEBPACK_IMPORTED_MODULE_1__.CODE});\n\n  // Browser side\n\n    const TVanillaViewLikeObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('VanillaViewLikeObject', {\n      code: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      externals: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      nodes: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      to: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`,\n      update: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`,\n      v: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      oldVals: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`\n    });\n\n    const TVanillaViewObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('VanillaViewObject', {\n      code: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      externals: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      nodes: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      to: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`,\n      update: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`,\n      v: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      oldVals: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`\n    }, {verify: v => verify(v)});\n\n    const TBangObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('BangObject', null, {\n      verify: v => v[Symbol.for('BANG-VV')]\n    });\n\n    const TComponent = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.defOr('Component', _t_js__WEBPACK_IMPORTED_MODULE_0__.T`VanillaViewObject`, _t_js__WEBPACK_IMPORTED_MODULE_0__.T`BangObject`)\n\n    const TVanillaViewArray = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.defCollection('VanillaViewArray', {\n      container: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      member: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Component`,\n    });\n\n  // SSR\n\n    const TSVanillaViewObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('SVanillaViewObject', {\n      str: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      handlers: THandlers\n    });\n\n    const TSVanillaViewArray = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.defCollection('SVanillaViewArray', {\n      container: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      member: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`SVanillaViewObject`\n    });\n\n  // export\n\n  const BS = {TKey,THandlers,TFuncArray,TVanillaViewObject,TVanillaViewLikeObject,TVanillaViewArray};\n\n  const SSR = {TKey,THandlers,TFuncArray,TSVanillaViewObject,TSVanillaViewArray};\n\n  const Types = {BS,SSR};\n\n\n  // verify function \n    function verify(v) {\n      return _common_js__WEBPACK_IMPORTED_MODULE_1__.CODE === v.code;\n    }\n\n\n\n//# sourceURL=webpack://bang.html/./src/vv/types.js?");

/***/ }),

/***/ "./src/vv/vanillaview.js":
/*!*******************************!*\
  !*** ./src/vv/vanillaview.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"s\": () => (/* binding */ s),\n/* harmony export */   \"c\": () => (/* binding */ c)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/vv/common.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ \"./src/vv/types.js\");\n// vanillaview.js\n  // imports\n    \n    \n\n  // backwards compatible alias\n    const skip = markup;\n    const attrskip = attrmarkup;\n\n  // constants\n    const DEBUG             = true;\n    const NULLFUNC          = () => void 0;\n    /* eslint-disable no-useless-escape */\n    const KEYMATCH          = /(?:<!\\-\\-)?(key\\d+)(?:\\-\\->)?/gm;\n    /* eslint-enable no-useless-escape */\n    const ATTRMATCH         = /\\w+=/;\n    const KEYLEN            = 20;\n    const XSS               = () => `Possible XSS / object forgery attack detected. ` +\n                              `Object code could not be verified.`;\n    const OBJ               = () => `Object values not allowed here.`;\n    const KEY               = v => `'key' property must be a string. Was: ${v.key}`;\n    const UNSET             = () => `Unset values not allowed here.`;\n    const INSERT            = () => `Error inserting template into DOM. ` +\n      `Position must be one of: ` +\n      `replace, beforebegin, afterbegin, beforeend, innerhtml, afterend`;\n    const NOTFOUND          = loc => `Error inserting template into DOM. ` +\n      `Location ${loc} was not found in the document.`;\n    const MOVE              = new class {\n      beforeend   (frag,elem) { elem.appendChild(frag) }\n      beforebegin (frag,elem) { elem.parentNode.insertBefore(frag,elem) }\n      afterend    (frag,elem) { elem.parentNode.insertBefore(frag,elem.nextSibling) }\n      replace     (frag,elem) { elem.parentNode.replaceChild(frag,elem) }\n      afterbegin  (frag,elem) { elem.insertBefore(frag,elem.firstChild) }\n      innerhtml   (frag,elem) { elem.innerHTML = ''; elem.appendChild(frag) }\n      insert      (frag,node) { node.replaceChildren(frag) }\n    };\n\n  // logging\n    globalThis.onerror = (...v) => (console.log(v, v[0]+'', v[4] && v[4].message, v[4] && v[4].stack), true);\n\n  // type functions\n    const isKey             = v => _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`Key`, v); \n    const isHandlers        = v => _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`Handlers`, v);\n\n  // cache \n    const cache = {};\n    // deux\n\n  // main exports \n    Object.assign(s,{say,attrskip,skip,attrmarkup,markup,guardEmptyHandlers,die});\n\n    Object.assign(globalThis, {vanillaview: {c, s, T: _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]}}); \n\n    async function s(p,...v) {\n      const that = this;\n      let SystemCall = false;\n      let state;\n\n      if ( p[0].length === 0 && v[0].state ) {\n        // by convention (see how we construct the template that we tag with FUNC)\n        // the first value is the state object when our system calls it\n        SystemCall = true;\n      }\n\n      if ( SystemCall ) {\n        ({state} = v.shift());\n        p.shift();\n        DEBUG && say('log','System VV_FUNC call: ' + v.join(', '));\n        v = await Promise.all(v.map(val => process(that, val, state)));\n        const xyz = vanillaview(p,v);\n        //xyz[Symbol.for('BANG-VV')] = true;\n        return xyz;\n      } else {\n        const laterFunc = async state => {\n          v = await Promise.all(v.map(val => process(that, val, state)));\n          const xyz = vanillaview(p,v);\n          //xyz[Symbol.for('BANG-VV')] = true;\n          return xyz;\n        };\n        //laterFunc[Symbol.for('BANG-VV')] = true;\n        DEBUG && console.log('async laterFunc', laterFunc);\n        return laterFunc;\n      }\n    }\n\n    function c(p,...v) {\n      return vanillaview(p,v, {useCache:false});\n    }\n\n  // main function (TODO: should we refactor?)\n    function vanillaview(p,v,{useCache:useCache=true}={}) {\n      const retVal = {};\n      let instanceKey, cacheKey;\n\n      v = v.map(guardAndTransformVal);\n\n      if ( useCache ) {\n        ({key:instanceKey} = (v.find(isKey) || {}));\n        cacheKey = p.join('<link rel=join>');\n        const {cached,firstCall} = isCached(cacheKey,v,instanceKey);\n       \n        if ( ! firstCall ) {\n          cached.update(v);\n          return cached;\n        } else {\n          retVal.oldVals = Array.from(v);\n        }\n      } else {\n        retVal.oldVals = Array.from(v);\n      }\n      \n      // compile the template into an updater\n\n      p = [...p]; \n      const vmap = {};\n      const V = v.map(replaceValWithKeyAndOmitInstanceKey(vmap));\n      const externals = [];\n      let str = '';\n\n      while( p.length > 1 ) str += p.shift() + V.shift();\n      str += p.shift();\n\n      const frag = toDOM(str);\n      const walker = document.createTreeWalker(frag, NodeFilter.SHOW_ALL);\n\n      do {\n        makeUpdaters({walker,vmap,externals});\n      } while(walker.nextNode())\n\n      Object.assign(retVal, {\n        externals,\n        v:Object.values(vmap),\n        to,\n        update,\n        code:_common_js__WEBPACK_IMPORTED_MODULE_0__.CODE,\n        nodes:[...frag.childNodes]\n      });\n\n      if ( useCache ) {\n        if ( instanceKey !== undefined ) {\n          cache[cacheKey].instances[instanceKey] = retVal;\n        } else {\n          cache[cacheKey] = retVal;\n        }\n      }\n\n      return retVal;\n    }\n\n\n  // bang integration functions (modified from bang versions)\n    async function process(that, x, state) {\n      if ( typeof x === 'string' ) return x;\n      else \n\n      if ( typeof x === 'number' ) return x+'';\n      else\n\n      if ( typeof x === 'boolean' ) return x+'';\n      else\n\n      if ( x instanceof Date ) return x+'';\n      else\n\n      if ( isUnset(x) ) {\n        if ( that.CONFIG.allowUnset ) return that.CONFIG.unsetPlaceholder || '';\n        else {\n          throw new TypeError(`Value cannot be unset, was: ${x}`);\n        }\n      }\n      else\n\n      if ( x instanceof Promise ) return await process(that, await x.catch(err => err+''), state);\n      else\n\n      if ( x instanceof Element ) return x.outerHTML;\n      else\n\n      if ( x instanceof Node ) return x.textContent;\n\n      const isVVArray   = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`VanillaViewArray`, x);\n      const isVVK = isKey(x);\n      const isMO    = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`MarkupObject`, x);\n      const isMAO = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`MarkupAttrObject`, x);\n      const isVV      = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`Component`, x);\n      if ( isVVArray || isVVK || isMO || isMAO || isVV ) {\n        DEBUG && console.log('vv', x, {isVVArray, isVVK, isMO, isMAO, isVV});\n        return isVVArray ? join(x) : x; // let vanillaview guardAndTransformVal handle\n      }\n      else\n      \n      if ( isIterable(x) ) {\n        // if an Array or iterable is given then\n        // its values are recursively processed via this same function\n        return process(that, (await Promise.all(\n          (\n            await Promise.all(Array.from(x)).catch(e => err+'')\n          ).map(v => process(that, v, state))\n        )), state);\n      }\n\n      else \n\n      if ( Object.getPrototypeOf(x).constructor.name === 'AsyncFunction' ) {\n        DEBUG && console.log('asyncfunc', x);\n        return await process(that, await x(state), state);\n      }\n      else\n\n      if ( x instanceof Function ) return x(state);\n      else // it's an object, of some type \n\n      {\n        // State store     \n          /* so we assume an object is state and save it */\n          /* to the global state store */\n          /* which is two-sides so we can find a key */\n          /* given an object. This avoid duplicates */\n        let stateKey;\n\n        // own keys\n          // an object can specify it's own state key\n          // to provide a single logical identity for a piece of state that may\n          // be represented by many objects\n\n        if ( Object.prototype.hasOwnProperty.call(x, that.CONFIG.bangKey) ) {\n          stateKey = new that.StateKey(x[that.CONFIG.bangKey])+'';\n          // in that case, replace the previously saved object with the same logical identity\n          const oldX = that.STATE.get(stateKey);\n          that.STATE.delete(oldX);\n\n          that.STATE.set(stateKey, x);\n          that.STATE.set(x, stateKey);\n        } \n\n        else  /* or the system can come up with a state key */\n\n        {\n          if ( that.STATE.has(x) ) stateKey = that.STATE.get(x);\n          else {\n            stateKey = new that.StateKey()+'';\n            that.STATE.set(stateKey, x);\n            that.STATE.set(x, stateKey);\n          }\n        }\n\n        stateKey += '';\n        DEBUG && say('log',{stateKey});\n        return stateKey;\n      }\n    }\n\n    function isIterable(y) {\n      if ( y === null ) return false;\n      return y[Symbol.iterator] instanceof Function;\n    }\n\n    function isUnset(x) {\n      return x === undefined || x === null;\n    }\n\n\n  // to function\n    function to(location, options) {\n      const position = (options || 'replace').toLocaleLowerCase();\n      const frag = document.createDocumentFragment();\n      this.nodes.forEach(n => frag.appendChild(n));\n      const isNode = location instanceof Node;\n      const elem = isNode ? location : document.querySelector(location);\n      try {\n        MOVE[position](frag,elem);\n      } catch(e) {\n        DEBUG && console.log({location,options,e,elem,isNode});\n        DEBUG && console.warn(e);\n        switch(e.constructor && e.constructor.name) {\n          case \"DOMException\":      die({error: INSERT()},e);             break;\n          case \"TypeError\":         die({error: NOTFOUND(location)},e);   break; \n          default:                  throw e;\n        }\n      }\n      while(this.externals.length) {\n        this.externals.shift()();\n      }\n    }\n\n  // update functions\n    function makeUpdaters({walker,vmap,externals}) {\n      const node = walker.currentNode;\n      switch( node.nodeType ) {\n        case Node.ELEMENT_NODE:\n          handleElement({node,vmap,externals}); break;\n        case Node.COMMENT_NODE:\n        case Node.TEXT_NODE:\n          handleNode({node,vmap,externals}); break;\n      }\n    }\n\n    function handleNode({node,vmap,externals}) {\n      const lengths = [];\n      const text = node.nodeValue; \n      let result = KEYMATCH.exec(text);\n      while ( result ) {\n        const {index} = result;\n        const key = result[1];\n        const val = vmap[key];\n        const replacer = makeNodeUpdater({node,index,lengths,val});\n        externals.push(() => replacer(val.val));\n        val.replacers.push( replacer );\n        result = KEYMATCH.exec(text);\n      }\n    }\n\n    // node functions\n      function makeNodeUpdater(nodeState) {\n        const {node} = nodeState;\n        const scope = Object.assign({}, nodeState, {\n          oldVal: {length: KEYLEN},\n          oldNodes: [node],\n          lastAnchor: node,\n        });\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"markupobject\": \n            case \"vanillaviewobject\":\n              handleMarkupInNode(newVal, scope); break;\n            default:\n              handleTextInNode(newVal, scope); break;\n          }\n        };\n      }\n\n      function handleMarkupInNode(newVal, state) {\n        let {oldNodes,lastAnchor} = state;\n        if ( newVal.nodes.length ) {\n          if ( sameOrder(oldNodes,newVal.nodes) ) {\n            // do nothing\n          } else {\n            // perf\n              // list updates could be possible more efficient\n              // this is if we are inserting new nodes\n              // but I can't imagine a way to do it that's not:\n              // 1) quadratic (edit distance)\n              // 2) lots of heuristics (did we insert a new node or nodes at the front? OK...etc...)\n            const LEGACY = false;\n            // log\n              console.group('old');\n              oldNodes.forEach(node => {\n                console.log(node.nodeName, document.contains(node.ownerDocument));\n              });\n              console.groupEnd();\n              console.group('new');\n              newVal.nodes.forEach(node => {\n                console.log(node.nodeName, document.contains(node.ownerDocument));\n              });\n              console.groupEnd();\n\n            if ( LEGACY ) {\n              Array.from(newVal.nodes).reverse().forEach(n => {\n                lastAnchor.parentNode.insertBefore(n,lastAnchor.nextSibling);\n                state.lastAnchor = lastAnchor.nextSibling;\n              });\n              state.lastAnchor = newVal.nodes[0];\n            } else {\n              const insertable = [];\n              newVal.nodes.forEach(node => {\n                const inserted = document.contains(node.ownerDocument);\n                if ( ! inserted ) insertable.push(node);\n                else {\n                  while( insertable.length ) {\n                    const insertee = insertable.shift();\n                    node.parentNode.insertBefore(insertee, node);\n                  }\n                }\n              });\n              while ( insertable.length ) {\n                const insertee = insertable.shift();\n                lastAnchor.parentNode.insertBefore(insertee,lastAnchor.nextSibling);\n              }\n              state.lastAnchor = newVal.nodes[0];\n            }\n          }\n        } else {\n          const placeholderNode = summonPlaceholder(lastAnchor);\n          lastAnchor.parentNode.insertBefore(placeholderNode,lastAnchor.nextSibling);\n          state.lastAnchor = placeholderNode;\n        }\n        // MARK: Unbond event might be relevant here.\n        // if nodes are not included we can just remove them\n        const dn = diffNodes(oldNodes,newVal.nodes);\n        if ( dn.size ) {\n          const f = document.createDocumentFragment();\n          dn.forEach(n => f.appendChild(n));\n        }\n        state.oldNodes = newVal.nodes || [lastAnchor];\n        while ( newVal.externals.length ) {\n          const func = newVal.externals.shift();\n          func();\n        } \n      }\n\n      function sameOrder(nodesA, nodesB) {\n        if ( nodesA.length != nodesB.length ) return false;\n\n        return Array.from(nodesA).every((an,i) => an == nodesB[i]);\n      }\n\n      function handleTextInNode(newVal, state) {\n        let {oldVal, index, val, lengths, node} = state;\n\n        const valIndex = val.vi;\n        const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n        const value = node.nodeValue;\n\n        lengths[valIndex] = newVal.length;\n\n        const correction = lengthBefore-originalLengthBefore;\n        const before = value.slice(0,index+correction);\n        const after = value.slice(index+correction+oldVal.length);\n\n        const newValue = before + newVal + after;\n\n        node.nodeValue = newValue;\n\n        state.oldVal = newVal;\n      }\n\n    // element attribute functions\n      function handleElement({node,vmap,externals}) {\n        getAttributes(node).forEach(({name,value} = {}) => {\n          const attrState = {node, vmap, externals, name, lengths: []};\n\n          KEYMATCH.lastIndex = 0;\n          let result = KEYMATCH.exec(name);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:true});\n            result = KEYMATCH.exec(name);\n          }\n\n          KEYMATCH.lastIndex = 0;\n          result = KEYMATCH.exec(value);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:false});\n            result = KEYMATCH.exec(value);\n          }\n        });\n      }\n\n      function prepareAttributeUpdater(result, attrState, {updateName}) {\n        const {index, input} = result;\n        const scope = Object.assign({}, attrState, {\n          index, input, updateName, \n          val: attrState.vmap[result[1]],\n          oldVal: {length: KEYLEN},\n          oldName: attrState.name,\n        });\n\n        let replacer;\n        if ( updateName ) {\n          replacer = makeAttributeNameUpdater(scope);\n        } else {\n          replacer = makeAttributeValueUpdater(scope);\n        }\n\n        scope.externals.push(() => replacer(scope.val.val));\n        scope.val.replacers.push( replacer );\n      }\n\n      // FIXME: needs to support multiple replacements just like value\n      // QUESTION: why is the variable oldName so required here, why can't we call it oldVal?\n      // if we do it breaks, WHY?\n      function makeAttributeNameUpdater(scope) {\n        let {oldName,node,val} = scope;\n        return (newVal) => {\n          if ( oldName == newVal ) return;\n          val.val = newVal;\n          const attr = node.hasAttribute(oldName) ? oldName : ''\n          if ( attr !== newVal ) {\n            if ( attr ) {\n              node.removeAttribute(oldName);\n              node[oldName] = undefined;\n            }\n            if ( newVal ) {\n              newVal = newVal.trim();\n\n              let name = newVal, value = undefined;\n\n              if( ATTRMATCH.test(newVal) ) {\n                const assignmentIndex = newVal.indexOf('='); \n                ([name,value] = [newVal.slice(0,assignmentIndex), newVal.slice(assignmentIndex+1)]);\n              }\n\n              reliablySetAttribute(node, name, value);\n            }\n            oldName = newVal;\n          }\n        };\n      }\n\n      function makeAttributeValueUpdater(scope) {\n        const updater = (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"funcarray\":       updateAttrWithFuncarrayValue(newVal, scope); break;\n            case \"function\":        updateAttrWithFunctionValue(newVal, scope); break;\n            case \"handlers\":        updateAttrWithHandlersValue(newVal, scope); break;\n            case \"markupobject\":     \n            case \"vanillaviewobject\": \n              newVal = nodesToStr(newVal.nodes); \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-disable no-fallthrough */\n            case \"markupattrobject\":  // deliberate fall through\n              newVal = newVal.str;\n            default:                \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-enable no-fallthrough */\n          }\n        };\n        // call it the first time so it loads well\n        // and we elide out the key placeholders here\n        updater(scope.val.val);\n        return updater;\n      }\n\n  // helpers\n    function getAttributes(node) {\n      if ( ! node.hasAttribute ) return [];\n\n      // for parity with classList.add (which trims whitespace)\n        // otherwise once the classList manipulation happens\n        // our indexes for replacement will be off\n      if ( node.hasAttribute('class') ) {\n        node.setAttribute('class', formatClassListValue(node.getAttribute('class')));\n      }\n      if ( !! node.attributes && Number.isInteger(node.attributes.length) ) return Array.from(node.attributes);\n      const attrs = [];\n      for ( const name of node ) {\n        if ( node.hasAttribute(name) ) {\n          attrs.push({name, value:node.getAttribute(name)});\n        }\n      }\n      return attrs;\n    }\n\n    function updateAttrWithFunctionValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          node.removeEventListener(name, oldVal, flags);\n        }\n        node.addEventListener(name, newVal, flags); \n        reliablySetAttribute(node, name, '');\n      } else {\n        if ( oldVal ) {\n          const index = externals.indexOf(oldVal);\n          if ( index >= 0 ) {\n            externals.splice(index,1);\n          }\n        }\n        externals.push(() => newVal(node)); \n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithFuncarrayValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( oldVal && ! Array.isArray(oldVal) ) {\n        oldVal = [oldVal]; \n      }\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          oldVal.forEach(of => node.removeEventListener(name, of, flags));\n        }\n        newVal.forEach(f => node.addEventListener(name, f, flags));\n      } else {\n        if ( oldVal ) {\n          oldVal.forEach(of => {\n            const index = externals.indexOf(of);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          });\n        }\n        newVal.forEach(f => externals.push(() => f(node)));\n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithHandlersValue(newVal, scope) {\n      let {oldVal,node,externals,} = scope;\n      if ( !!oldVal && _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`Handlers`, oldVal) ) {\n        Object.entries(oldVal).forEach(([eventName,funcVal]) => {\n          if ( eventName !== 'bond' ) {\n            let flags = {};\n            if ( eventName.includes(':') ) {\n              ([eventName, ...flags] = eventName.split(':'));\n              flags = flags.reduce((O,f) => {\n                O[f] = true;\n                return O;\n              }, {});\n            }\n            console.log(eventName, funcVal, flags);\n            node.removeEventListener(eventName, funcVal, flags); \n          } else {\n            const index = externals.indexOf(funcVal);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          }\n        });\n      }\n      Object.entries(newVal).forEach(([eventName,funcVal]) => {\n        if ( eventName !== 'bond' ) {\n          let flags = {};\n          if ( eventName.includes(':') ) {\n            ([eventName, ...flags] = eventName.split(':'));\n            flags = flags.reduce((O,f) => {\n              O[f] = true;\n              return O;\n            }, {});\n          }\n          node.addEventListener(eventName, funcVal, flags); \n        } else {\n          externals.push(() => funcVal(node)); \n        }\n      });\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithTextValue(newVal, scope) {\n      let {oldVal,node,index,name,val,lengths} = scope;\n      let zeroWidthCorrection = 0;\n      const valIndex = val.vi;\n      const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        \n      // we need to trim newVal to have parity with classlist add\n        // the reason we have zeroWidthCorrection = -1\n        // is because the classList is a set of non-zero width tokens\n        // separated by spaces\n        // when we have a zero width token, we have two adjacent spaces\n        // which, by virtue of our other requirement, gets replaced by a single space\n        // effectively elliding out our replacement location\n        // in order to keep our replacement location in tact\n        // we need to compensate for the loss of a token slot (effectively a token + a space)\n        // and having a -1 correction effectively does this.\n      if ( name == \"class\" ) {\n        newVal = newVal.trim();\n        if ( newVal.length == 0 ) {\n          zeroWidthCorrection = -1;\n        }\n        scope.val.val = newVal;\n      }\n      lengths[valIndex] = newVal.length + zeroWidthCorrection;\n      let attr = node.getAttribute(name);\n\n      const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n\n      const correction = lengthBefore-originalLengthBefore;\n      const before = attr.slice(0,index+correction);\n      const after = attr.slice(index+correction+oldVal.length);\n\n      let newAttrValue;\n      \n      if ( name == \"class\" ) {\n        const spacer = oldVal.length == 0 ? ' ' : '';\n        newAttrValue = before + spacer + newVal + spacer + after;\n      } else {\n        newAttrValue = before + newVal + after;\n      }\n\n      DEBUG && console.log(JSON.stringify({\n        newVal,\n        valIndex,\n        lengths,\n        attr,\n        lengthBefore,\n        originalLengthBefore,\n        correction,\n        before,\n        after,\n        newAttrValue\n      }, null, 2));\n\n      reliablySetAttribute(node, name, newAttrValue);\n\n      scope.oldVal = newVal;\n    }\n\n    function reliablySetAttribute(node, name, value ) {\n      if (  name == \"class\" ) {\n        value = formatClassListValue(value);\n      }\n\n      try {\n        node.setAttribute(name,value);\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n\n      try {\n        node[name] = value == undefined ? true : value;\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n    }\n\n    function getType(val) {\n      const type = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`Function`, val) ? 'function' :\n        _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`Handlers`, val) ? 'handlers' : \n        _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`VanillaViewObject`, val) ? 'vanillaviewobject' : \n        _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`MarkupObject`, val) ? 'markupobject' :\n        _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`MarkupAttrObject`, val) ? 'markupattrobject' :\n        _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`VanillaViewArray`, val) ? 'vanillaviewarray' : \n        _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`FuncArray`, val) ? 'funcarray' : \n        'default'\n      ;\n      return type;\n    }\n\n    function summonPlaceholder(sibling) {\n      let ph = [...sibling.parentNode.childNodes].find(\n        node => node.nodeType == Node.COMMENT_NODE && node.nodeValue == 'vanillaview-placeholder' );\n      if ( ! ph ) {\n        ph = toDOM(`<!--vanillaview-placeholder-->`).firstChild;\n      }\n      return ph;\n    }\n\n    // cache helpers\n      // FIXME: function needs refactor\n      function isCached(cacheKey,v,instanceKey) {\n        let firstCall;\n        let cached = cache[cacheKey];\n        if ( cached == undefined ) {\n          cached = cache[cacheKey] = {};\n          if ( instanceKey !== undefined ) {\n            cached.instances = {};\n            cached = cached.instances[instanceKey] = {};\n          }\n          firstCall = true;\n        } else {\n          if ( instanceKey !== undefined ) {\n            if ( ! cached.instances ) {\n              cached.instances = {};\n              firstCall = true;\n            } else {\n              cached = cached.instances[instanceKey];\n              if ( ! cached ) {\n                firstCall = true;\n              } else {\n                firstCall = false;\n              }\n            }\n          } else {\n            firstCall = false;\n          }\n        }\n        return {cached,firstCall};\n      }\n\n    // Markup helpers\n      // Returns an object that VanillaView treats as markup,\n      // even tho it is NOT a VanillaView Object (defined with R/X/$)\n      // And even tho it is in the location of a template value replacement\n      // Which would normally be the treated as String\n      function markup(str) {\n        str = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`None`, str) ? '' : str; \n        const frag = toDOM(str);\n        const retVal = {\n          type: 'MarkupObject',\n          code:_common_js__WEBPACK_IMPORTED_MODULE_0__.CODE,\n          nodes:[...frag.childNodes],\n          externals: []\n        };\n        return retVal;\n      }\n\n      // Returns an object that VanillaView treats, again, as markup\n      // But this time markup that is OKAY to have within a quoted attribute\n      function attrmarkup(str) {\n        str = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`None`, str) ? '' : str; \n        str = str.replace(/\"/g,'&quot;');\n        const retVal = {\n          type: 'MarkupAttrObject',\n          code: _common_js__WEBPACK_IMPORTED_MODULE_0__.CODE,\n          str\n        };\n        return retVal;\n      }\n\n      function guardEmptyHandlers(val) {\n        if ( Array.isArray(val) ) {\n          if ( val.length == 0 ) {\n            return [NULLFUNC]\n          } \n          return val;\n        } else {\n          if ( _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`None`, val) ) {\n            return NULLFUNC;\n          }\n        }\n      }\n\n    // other helpers\n      function formatClassListValue(value) {\n        value = value.trim();\n        value = value.replace(/\\s+/g, ' ');\n        return value;\n      }\n\n      function replaceValWithKeyAndOmitInstanceKey(vmap) {\n        return (val,vi) => {\n          // omit instance key\n          if ( _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`Key`, val) ) {\n            return '';\n          }\n          const key = ('key'+Math.random()).replace('.','').padEnd(KEYLEN,'0').slice(0,KEYLEN);\n          let k = key;\n          if ( _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`VanillaViewObject`, val) || _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`MarkupObject`, val) ) {\n            k = `<!--${k}-->`;\n          }\n          vmap[key.trim()] = {vi,val,replacers:[]};\n          return k;\n        };\n      }\n\n      function toDOM(str) {\n        const templateEl = (new DOMParser).parseFromString(\n          `<template>${str}</template>`,\"text/html\"\n        ).head.firstElementChild;\n        let f;\n        if ( templateEl instanceof HTMLTemplateElement ) { \n          f = templateEl.content;\n          f.normalize();\n          return f;\n        } else {\n          throw new TypeError(`Could not find template element after parsing string to DOM:\\n=START=\\n${str}\\n=END=`);\n        }\n      }\n\n      function guardAndTransformVal(v) {\n        const isFunc          = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`Function`, v);\n        const isUnset         = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`None`, v);\n        const isObject        = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`Object`, v);\n        const isVanillaViewArray   = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`VanillaViewArray`, v);\n        const isFuncArray     = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`FuncArray`, v);\n        const isMarkupObject    = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`MarkupObject`, v);\n        const isMarkupAttrObject= _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`MarkupAttrObject`, v);\n        const isVanillaView        = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`VanillaViewObject`, v);\n        const isForgery       = _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`VanillaViewLikeObject`, v)  && !isVanillaView; \n\n        if ( isFunc )             return v;\n        if ( isVanillaView )           return v;\n        if ( isKey(v) )           return v;\n        if ( isHandlers(v) )      return v;\n        if ( isVanillaViewArray )      return join(v); \n        if ( isFuncArray )        return v;\n        if ( isMarkupObject )     return v;\n        if ( isMarkupAttrObject)  return v;\n\n        if ( isUnset )            die({error: UNSET()});\n        if ( isForgery )          die({error: XSS()});\n\n        if ( isObject )       {\n          if ( Object.keys(v).join(',') === \"key\" ) {\n            die({error: KEY(v)});    \n          } else die({error: OBJ()});\n        }\n\n        return v+'';\n      }\n\n      function join(os) {\n        const externals = [];\n        const bigNodes = [];\n        const v = [];\n        const oldVals = [];\n        os.forEach(o => {\n          //v.push(...o.v); \n          //oldVals.push(...o.oldVals);\n          externals.push(...o.externals);\n          bigNodes.push(...o.nodes);\n        });\n        DEBUG && console.log({oldVals,v});\n        const retVal = {v,code:_common_js__WEBPACK_IMPORTED_MODULE_0__.CODE,oldVals,nodes:bigNodes,to,update,externals};\n        return retVal;\n      }\n\n      function nodesToStr(nodes) {\n        const frag = document.createDocumentFragment();\n        nodes.forEach(n => frag.appendChild(n.cloneNode(true)));\n        const container = document.createElement('body');\n        container.appendChild(frag);\n        return container.innerHTML;\n      }\n\n      function diffNodes(last,next) {\n        last = new Set(last);\n        next = new Set(next);\n        return new Set([...last].filter(n => !next.has(n)));\n      }\n\n      function update(newVals) {\n        const updateable = this.v.filter(({vi}) => didChange(newVals[vi], this.oldVals[vi]));\n        DEBUG && console.log({updateable, oldVals:this.oldVals, newVals});\n        updateable.forEach(({vi,replacers}) => replacers.forEach(f => f(newVals[vi])));\n        this.oldVals = Array.from(newVals);\n      }\n\n      function didChange(oldVal, newVal) {\n        DEBUG && console.log({oldVal,newVal});\n        const [oldType, newType] = [oldVal, newVal].map(getType); \n        let ret;\n        if ( oldType != newType ) {\n          ret =  true;\n        } else {\n          switch(oldType) {\n            case \"vanillaviewobject\":\n              // the vanillaview object is returned by a view function\n              // which has already called its updaters and checked its slot values\n              // to determine and show changes\n              // except in the case of a list of nodes\n              ret = true;\n              break;\n            /* eslint-disable no-fallthrough */\n            case \"funcarray\":\n            case \"function\":\n              // hard to equate even if same str value as scope could be diff\n              ret = true;\n              break;\n            case \"vanillaviewarray\":\n              // need to do array dif so don't do here\n              ret = true;\n              break;\n            case \"markupattrobject\":\n            case \"markupobject\":\n              // need to check multiple things\n              ret = true;\n              break;\n            default:\n              ret = JSON.stringify(oldVal) !== JSON.stringify(newVal);\n              break;\n            /* eslint-enable no-fallthrough */\n          }\n        }\n\n        DEBUG && console.log({ret});\n        return ret;\n      }\n\n  // reporting and error helpers \n    function die(msg,err) {\n      if (DEBUG && err) console.warn(err);\n      msg.stack = ((DEBUG && err) || new Error()).stack.split(/\\s*\\n\\s*/g);\n      throw JSON.stringify(msg,null,2);\n    }\n\n    function say(msg) {\n      if ( DEBUG ) {\n        console.log(JSON.stringify(msg,showNodes,2));\n        console.info('.');\n      }\n    }\n\n    function showNodes(k,v) {\n      let out = v;\n      if ( _types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].check(_types_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]`>Node`, v) ) {\n        out = `<${v.nodeName.toLowerCase()} ${\n          !v.attributes ? '' : [...v.attributes].map(({name,value}) => `${name}='${value}'`).join(' ')}>${\n          v.nodeValue || (v.children && v.children.length <= 1 ? v.innerText : '')}`;\n      } else if ( typeof v === \"function\" ) {\n        return `${v.name || 'anon'}() { ... }`\n      }\n      return out;\n    }\n\n\n//# sourceURL=webpack://bang.html/./src/vv/vanillaview.js?");

/***/ })

}]);