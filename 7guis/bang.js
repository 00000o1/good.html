/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/cat.bang.js":
/*!*************************!*\
  !*** ./src/cat.bang.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  0;\n}(this, (function (exports) {\n  // common for all r submodules\n    const CODE              = ''+Math.random();\n\n  const BROWSER_SIDE      = (() => {try{ return self.DOMParser && true; } catch(e) { return false; }})();\n\n    const BuiltIns = [\n      Symbol, Boolean, Number, String, Object, Set, Map, WeakMap, WeakSet,\n      Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,\n      Int8Array, Int16Array, Int32Array, \n      Uint8ClampedArray, \n      ...(BROWSER_SIDE ? [\n        Node,NodeList,Element,HTMLElement, Blob, ArrayBuffer,\n        FileList, Text, HTMLDocument, Document, DocumentFragment,\n        Error, File, Event, EventTarget, URL\n      /* eslint-disable no-undef */\n      ] : [ Buffer ])\n      /* eslint-enable no-undef */\n    ];\n    const SEALED_DEFAULT = true;\n    const isNone = instance => instance == null || instance == undefined;\n\n    const typeCache = new Map();\n\n    T.def = def;\n    T.check = check;\n    T.sub = sub;\n    T.verify = verify$1;\n    T.validate = validate;\n    T.partialMatch = partialMatch;\n    T.defEnum = defEnum;\n    T.defSub = defSub;\n    T.defTuple = defTuple;\n    T.defCollection = defCollection;\n    T.defOr = defOr;\n    T.option = option;\n    T.defOption = defOption;\n    T.maybe = maybe;\n    T.guard = guard;\n    T.errors = errors;\n\n    T[Symbol.for('jtype-system.typeCache')] = typeCache;\n\n    defineSpecials();\n    mapBuiltins();\n\n    function T(parts, ...vals) {\n      const cooked = vals.reduce((prev,cur,i) => prev+cur+parts[i+1], parts[0]);\n      const typeName = cooked;\n      if ( !typeCache.has(typeName) ) throw new TypeError(`Cannot use type ${typeName} before it is defined.`);\n      return typeCache.get(typeName).type;\n    }\n\n    function partialMatch(type, instance) {\n      return validate(type, instance, {partial:true});\n    }\n\n    function validate(type, instance, {partial: partial = false} = {}) {\n      guardType(type);\n      guardExists(type);\n      const typeName = type.name;\n\n      const {spec,kind,help,verify,verifiers,sealed} = typeCache.get(typeName);\n\n      const specKeyPaths = spec ? allKeyPaths(spec).sort() : [];\n      const specKeyPathSet = new Set(specKeyPaths);\n\n      const bigErrors = [];\n\n      switch(kind) {\n        case \"def\": {\n          let allValid = true;\n          if ( spec ) {\n            const keyPaths = partial ? allKeyPaths(instance, specKeyPathSet) : specKeyPaths;\n            allValid = !isNone(instance) && keyPaths.every(kp => {\n              // Allow lookup errors if the type match for the key path can include None\n\n              const {resolved, errors:lookupErrors} = lookup(instance,kp,() => checkTypeMatch(lookup(spec,kp).resolved, T`None`));\n              bigErrors.push(...lookupErrors);\n\n              if ( lookupErrors.length ) return false;\n\n              const keyType = lookup(spec,kp).resolved;\n              if ( !keyType || !(keyType instanceof Type) ) {\n                bigErrors.push({\n                  error: `Key path '${kp}' is not present in the spec for type '${typeName}'`\n                });\n                return false;\n              }\n\n              const {valid, errors: validationErrors} = validate(keyType, resolved);\n              bigErrors.push(...validationErrors);\n\n              return valid;\n            });\n          }\n          let verified = true;\n          if ( partial && ! spec && !!verify ) {\n            throw new TypeError(`Type checking with option 'partial' is not a valid option for types that` + \n              ` only use a verify function but have no spec`);\n          } else if ( verify ) {\n            try {\n              verified = verify(instance);\n              if ( ! verified ) {\n                if ( verifiers ) {\n                  throw {\n                    error:`Type ${typeName} value '${JSON.stringify(instance)}' violated at least 1 verify function in:\\n${\n                    verifiers.map(f => '\\t'+(f.help||'') + ' ('+f.verify.toString()+')').join('\\n')\n                  }`\n                  };\n                } else if ( type.isSumType ) {\n                  throw {\n                    error: `Value '${JSON.stringify(instance)}' did not match any of: ${[...type.types.keys()].map(t => t.name)}`,\n                    verify, verifiers\n                  }\n                } else {\n                  let helpMsg = '';\n                  if ( help ) {\n                    helpMsg = `Help: ${help}. `;\n                  }\n                  throw {error:`${helpMsg}Type ${typeName} Value '${JSON.stringify(instance)}' violated verify function in: ${verify.toString()}`};\n                }\n              }\n            } catch(e) {\n              bigErrors.push(e);\n              verified = false;\n            }\n          }\n          let sealValid = true;\n          if ( !!sealed && !! spec ) {\n            const type_key_paths = specKeyPaths;\n            const all_key_paths = allKeyPaths(instance, specKeyPathSet).sort();\n            sealValid  = all_key_paths.join(',') == type_key_paths.join(',');\n            if ( ! sealValid ) {\n              if ( all_key_paths.length < type_key_paths.length ) {\n                sealValid = true;\n              } else {\n                const errorKeys = [];\n                const tkp = new Set(type_key_paths); \n                for( const k of all_key_paths ) {\n                  if ( ! tkp.has(k) ) {\n                    errorKeys.push({\n                      error: `Key path '${k}' is not in the spec for type ${typeName}`\n                    });\n                  }\n                }\n                if ( errorKeys.length ) {\n                  bigErrors.push(...errorKeys);\n                }\n              }\n            }\n          }\n          return {valid: allValid && verified && sealValid, errors: bigErrors, partial}\n        } case \"defCollection\": {\n          const {valid:containerValid, errors:containerErrors} = validate(spec.container, instance);\n          let membersValid = true;\n          let verified = true;\n\n          bigErrors.push(...containerErrors);\n          if ( partial ) {\n            throw new TypeError(`Type checking with option 'partial' is not a valid option for Collection types`);\n          } else {\n            if ( containerValid ) {\n               membersValid= [...instance].every(member => {\n                const {valid, errors} = validate(spec.member, member);\n                bigErrors.push(...errors);\n                return valid;\n              });\n            }\n            if ( verify ) {\n              try {\n                verified = verify(instance);\n              } catch(e) {\n                bigErrors.push(e);\n                verified = false;\n              }\n            }\n          }\n            \n          return {valid:containerValid && membersValid && verified, errors:bigErrors};\n        } default: {\n          throw new TypeError(`Checking for type kind ${kind} is not yet implemented.`);\n        }\n      }\n    }\n\n    function check(...args) {\n      return validate(...args).valid;\n    }\n\n    function lookup(obj, keyPath, canBeNone) {\n      if ( isNone(obj) ) throw new TypeError(`Lookup requires a non-unset object.`);\n\n      if ( !keyPath ) throw new TypeError(`keyPath must not be empty`);\n\n\n      const keys = keyPath.split(/\\./g);\n      const pathComplete = [];\n      const errors = [];\n\n      let resolved = obj;\n\n      while(keys.length) {\n        const nextKey = keys.shift();\n        resolved = resolved[nextKey];\n        pathComplete.push(nextKey);\n        if ( (resolved === null || resolved === undefined) ) {\n          if ( keys.length ) {\n            errors.push({\n              error: \n                `Lookup on key path '${keyPath}' failed at '` + \n                pathComplete.join('.') +\n                `' when ${resolved} was found at '${nextKey}'.` \n            });\n          } else if ( !!canBeNone && canBeNone() ) {\n            resolved = undefined;\n          } else {\n            errors.push({\n              error: \n                `Resolution on key path '${keyPath}' failed` + \n                `when ${resolved} was found at '${nextKey}' and the Type of this` +\n                `key's value cannot be None.`\n            });\n          }\n          break;\n        }\n      }\n      return {resolved,errors};\n    }\n\n    function checkTypeMatch(typeA, typeB) {\n      guardType(typeA);\n      guardExists(typeA);\n      guardType(typeB);\n      guardExists(typeB);\n\n      if ( typeA === typeB ) {\n        return true;\n      } else if ( typeA.isSumType && typeA.types.has(typeB) ) {\n        return true;\n      } else if ( typeB.isSumType && typeB.types.has(typeA) ) {\n        return true;\n      } else if ( typeA.name.startsWith('?') && typeB == T`None` ) {\n        return true;\n      } else if ( typeB.name.startsWith('?') && typeA == T`None` ) {\n        return true;\n      }\n\n      if ( typeA.name.startsWith('>') || typeB.name.startsWith('>') ) {\n        console.error(new Error(`Check type match has not been implemented for derived//sub types yet.`));\n      }\n\n      return false;\n    }\n\n    function option(type) {\n      return T`?${type.name}`;\n    }\n\n    function sub(type) {\n      return T`>${type.name}`;\n    }\n\n    function defSub(type, spec, {verify: verify = undefined, help:help = ''} = {}, name = '') {\n      guardType(type);\n      guardExists(type);\n\n      let verifiers;\n\n      if ( ! verify ) {\n        verify = () => true;\n      } \n\n      if ( type.native ) {\n        verifiers = [ {help,verify} ];\n        verify = i => i instanceof type.native;\n        const helpMsg = `Needs to be of type ${type.native.name}. ${help||''}`;\n        verifiers.push({help:helpMsg,verify});\n      }\n\n      const newType = def(`${name}>${type.name}`, spec, {verify,help, verifiers});\n      return newType;\n    }\n\n    function defEnum(name, ...values) {\n      if ( !name ) throw new TypeError(`Type must be named.`); \n      guardRedefinition(name);\n      \n      const valueSet = new Set(values);\n      const verify = i => valueSet.has(i);\n      const help = `Value of Enum type ${name} must be one of ${values.join(',')}`;\n\n      return def(name, null, {verify,help});\n    }\n\n    function exists(name) {\n      return typeCache.has(name);\n    }\n\n    function guardRedefinition(name) {\n      if ( exists(name) ) throw new TypeError(`Type ${name} cannot be redefined.`);\n    }\n\n    function allKeyPaths(o, specKeyPaths) {\n      const isTypeSpec = ! specKeyPaths;\n      const keyPaths = new Set();\n      return recurseObject(o, keyPaths, '');\n\n      function recurseObject(o, keyPathSet, lastLevel = '') {\n        const levelKeys = Object.getOwnPropertyNames(o); \n        const keyPaths = levelKeys\n          .map(k => lastLevel + (lastLevel.length ? '.' : '') + k);\n        levelKeys.forEach((k,i) => {\n          const v = o[k];\n          if ( isTypeSpec ) {\n            if ( v instanceof Type ) {\n              keyPathSet.add(keyPaths[i]);\n            } else if ( typeof v == \"object\" ) {\n              if ( ! Array.isArray(v) ) {\n                recurseObject(v, keyPathSet, keyPaths[i]);\n              } else {\n                throw new TypeError(`We don't support Types that use Arrays as structure, just yet.`); \n              }\n            } else {\n              throw new TypeError(`Spec cannot contain leaf values that are not valid Types`);\n            }\n          } else {\n            if ( specKeyPaths.has(keyPaths[i]) ) {\n              keyPathSet.add(keyPaths[i]); \n            } else if ( typeof v == \"object\" ) {\n              if ( k === '_self' ) ; else if ( ! Array.isArray(v) ) {\n                recurseObject(v, keyPathSet, keyPaths[i]);\n              } else {\n                v.forEach((item,index) => recurseObject(item, keyPathSet, keyPaths[i] + '.' + index));\n                //throw new TypeError(`We don't support Instances that use Arrays as structure, just yet.`); \n              }\n            } else {\n              //console.warn(\"Spec has no such key\",  keyPaths[i]);\n              keyPathSet.add(keyPaths[i]);\n            }\n          }\n        });\n        return [...keyPathSet];\n      }\n    }\n\n    function defOption(type) {\n      guardType(type);\n      const typeName = type.name;\n      return T.def(`?${typeName}`, null, {verify: i => isUnset$1(i) || T.check(type,i)});\n    }\n\n    function maybe(type) {\n      try {\n        return defOption(type);\n      } catch(e) {\n        // console.log(`Option Type ${type.name} already declared.`, e);\n      }\n      return T`?${type.name}`;\n    }\n\n    function verify$1(...args) { return check(...args); }\n\n    function defCollection(name, {container, member}, {sealed: sealed = SEALED_DEFAULT, verify: verify = undefined} = {}) {\n      if ( !name ) throw new TypeError(`Type must be named.`); \n      if ( !container || !member ) throw new TypeError(`Type must be specified.`);\n      guardRedefinition(name);\n\n      const kind = 'defCollection';\n      const t = new Type(name);\n      const spec = {kind, spec: { container, member}, verify, sealed, type: t};\n      typeCache.set(name, spec);\n      return t;\n    }\n\n    function defTuple(name, {pattern}) {\n      if ( !name ) throw new TypeError(`Type must be named.`); \n      if ( !pattern ) throw new TypeError(`Type must be specified.`);\n      const kind = 'def';\n      const specObj = {};\n      pattern.forEach((type,key) => specObj[key] = type);\n      const t = new Type(name);\n      const spec = {kind, spec: specObj, type:t};\n      typeCache.set(name, spec);\n      return t;\n    }\n\n    function Type(name, mods = {}) {\n      if ( ! new.target ) throw new TypeError(`Type with new only.`);\n      Object.defineProperty(this,'name', {get: () => name});\n      this.typeName = name;\n\n      if ( mods.types ) {\n        const {types} = mods;\n        const typeSet = new Set(types);\n        Object.defineProperty(this,'isSumType', {get: () => true});\n        Object.defineProperty(this,'types', {get: () => typeSet});\n      }\n\n      if ( mods.native ) {\n        const {native} = mods;\n        Object.defineProperty(this,'native', {get: () => native});\n      }\n    }\n\n    Type.prototype.toString = function () {\n      return `${this.typeName} Type`;\n    };\n\n    function def(name, spec, {help:help = '', verify:verify = undefined, sealed:sealed = undefined, types:types = undefined, verifiers:verifiers = undefined, native:native = undefined} = {}) {\n      if ( !name ) throw new TypeError(`Type must be named.`); \n      guardRedefinition(name);\n\n      if ( name.startsWith('?') ) {\n        if ( spec ) {\n          throw new TypeError(`Option type can not have a spec.`);\n        } \n\n        if ( ! verify(null) ) {\n          throw new TypeError(`Option type must be OK to be unset.`);\n        }\n      }\n\n      const kind = 'def';\n      if ( sealed === undefined ) {\n        sealed = true;\n      }\n      const t = new Type(name, {types, native});\n      const cache = {spec,kind,help,verify,verifiers,sealed,types,native,type:t};\n      typeCache.set(name, cache);\n      return t;\n    }\n\n    function defOr(name, ...types) {\n      return T.def(name, null, {types, verify: i => types.some(t => check(t,i))});\n    }\n\n    function guard(type, instance) {\n      guardType(type);\n      guardExists(type);\n      const {valid, errors} = validate(type, instance);\n      if ( ! valid ) throw new TypeError(`Type ${type} requested, but item is not of that type: ${errors.join(', ')}`);\n    }\n\n    function guardType(t) {\n      //console.log(t);\n      if ( !(t instanceof Type) ) throw new TypeError(`Type must be a valid Type object.`);\n    }\n\n    function guardExists(t) {\n      const name = originalName(t);\n      if ( ! exists(name) ) throw new TypeError(`Type must exist. Type ${name} has not been defined.`);\n    }\n\n    function errors(...args) {\n      return validate(...args).errors;\n    }\n\n    function mapBuiltins() {\n      BuiltIns.forEach(t => def(originalName(t), null, {native: t, verify: i => originalName(i.constructor) === originalName(t)}));  \n      BuiltIns.forEach(t => defSub(T`${originalName(t)}`));  \n    }\n\n    function defineSpecials() {\n      T.def(`Any`, null, {verify: () => true});\n      T.def(`Some`, null, {verify: i => !isUnset$1(i)});\n      T.def(`None`, null, {verify: i => isUnset$1(i)});\n      T.def(`Function`, null, {verify: i => i instanceof Function});\n      T.def(`Integer`, null, {verify: i => Number.isInteger(i)});\n      T.def(`Array`, null, {verify: i => Array.isArray(i)});\n      T.def(`Iterable`, null, {verify: i => i[Symbol.iterator] instanceof Function});\n    }\n\n    function isUnset$1(i) {\n      return i === null || i === undefined;\n    }\n\n    function originalName(t) {\n      if (!!t && t.name) {\n        return t.name;\n      } \n      const oName = Object.prototype.toString.call(t).replace(/\\[object |\\]/g, '');\n      if ( oName.endsWith('Constructor') ) {\n        return oName.replace(/Constructor$/,'');\n      }\n      return oName;\n    }\n\n  // types\n\n    // Both SSR and Browser\n\n      T.defOr('KeyValue', T`String`, T`Number`);\n\n      T.def('Key', {\n        key: T`KeyValue`\n      });\n\n      const THandlers = T.def('Handlers', null, {verify: i => {\n        const validObject = T.check(T`Object`, i);\n\n        if ( ! validObject ) return false;\n\n        const eventNames = Object.keys(i);\n        const handlerFuncs = Object.values(i);\n        const validNames = eventNames.every(name => T.check(T`String`, name));\n        const validFuncs = handlerFuncs.every(func => T.check(T`Function`, func));\n        const valid = validNames && validFuncs;\n\n        return valid;\n      }});\n\n      T.defCollection('FuncArray', {\n        container: T`Array`,\n        member: T`Function`\n      });\n\n      T.def('EmptyArray', null, {verify: i => Array.isArray(i) && i.length == 0});\n\n      T.def('MarkupObject', {\n        type: T`String`,\n        code: T`String`,\n        nodes: T`Array`,\n        externals: T`Array`,\n      }, {verify: v => v.type == 'MarkupObject' && v.code == CODE});\n\n      T.def('MarkupAttrObject', {\n        type: T`String`,\n        code: T`String`,\n        str: T`String`\n      }, {verify: v => v.type == 'MarkupAttrObject' && v.code == CODE});\n\n    // Browser side\n\n      T.def('VanillaViewLikeObject', {\n        code: T`String`,\n        externals: T`Array`,\n        nodes: T`Array`,\n        to: T`Function`,\n        update: T`Function`,\n        v: T`Array`,\n        oldVals: T`Array`\n      });\n\n      T.def('VanillaViewObject', {\n        code: T`String`,\n        externals: T`Array`,\n        nodes: T`Array`,\n        to: T`Function`,\n        update: T`Function`,\n        v: T`Array`,\n        oldVals: T`Array`\n      }, {verify: v => verify(v)});\n\n      T.def('BangObject', null, {\n        verify: v => v[Symbol.for('BANG-VV')]\n      });\n\n      T.defOr('Component', T`VanillaViewObject`, T`BangObject`);\n\n      T.defCollection('VanillaViewArray', {\n        container: T`Array`,\n        member: T`Component`,\n      });\n\n    // SSR\n\n      T.def('SVanillaViewObject', {\n        str: T`String`,\n        handlers: THandlers\n      });\n\n      T.defCollection('SVanillaViewArray', {\n        container: T`Array`,\n        member: T`SVanillaViewObject`\n      });\n\n\n    // verify function \n      function verify(v) {\n        return CODE === v.code;\n      }\n\n  // vanillaview.js\n\n    // backwards compatible alias\n      const skip = markup;\n      const attrskip = attrmarkup;\n      const NULLFUNC          = () => void 0;\n      /* eslint-disable no-useless-escape */\n      const KEYMATCH          = /(?:<!\\-\\-)?(key\\d+)(?:\\-\\->)?/gm;\n      /* eslint-enable no-useless-escape */\n      const ATTRMATCH         = /\\w+=/;\n      const KEYLEN            = 20;\n      const XSS               = () => `Possible XSS / object forgery attack detected. ` +\n                                `Object code could not be verified.`;\n      const OBJ               = () => `Object values not allowed here.`;\n      const KEY               = v => `'key' property must be a string. Was: ${v.key}`;\n      const UNSET             = () => `Unset values not allowed here.`;\n      const INSERT            = () => `Error inserting template into DOM. ` +\n        `Position must be one of: ` +\n        `replace, beforebegin, afterbegin, beforeend, innerhtml, afterend`;\n      const NOTFOUND          = loc => `Error inserting template into DOM. ` +\n        `Location ${loc} was not found in the document.`;\n      const MOVE              = new class {\n        beforeend   (frag,elem) { elem.appendChild(frag); }\n        beforebegin (frag,elem) { elem.parentNode.insertBefore(frag,elem); }\n        afterend    (frag,elem) { elem.parentNode.insertBefore(frag,elem.nextSibling); }\n        replace     (frag,elem) { elem.parentNode.replaceChild(frag,elem); }\n        afterbegin  (frag,elem) { elem.insertBefore(frag,elem.firstChild); }\n        innerhtml   (frag,elem) { elem.innerHTML = ''; elem.appendChild(frag); }\n        insert      (frag,node) { node.replaceChildren(frag); }\n      };\n\n    // logging\n      /*globalThis.onerror = (...v) => (console.log(v, v[0]+'', v[4] && v[4].message, v[4] && v[4].stack), true);*/\n\n    // type functions\n      const isKey             = v => T.check(T`Key`, v); \n      const isHandlers        = v => T.check(T`Handlers`, v);\n\n    // cache \n      const cache = {};\n      // deux\n\n    // main exports \n      Object.assign(s,{say,attrskip,skip,attrmarkup,markup,guardEmptyHandlers,die});\n\n      Object.assign(globalThis, {vanillaview: {c, s, T}}); \n\n      async function s(p,...v) {\n        const that = this;\n        let SystemCall = false;\n        let state;\n\n        if ( p[0].length === 0 && v[0].state ) {\n          // by convention (see how we construct the template that we tag with FUNC)\n          // the first value is the state object when our system calls it\n          SystemCall = true;\n        }\n\n        if ( SystemCall ) {\n          ({state} = v.shift());\n          p.shift();\n          v = await Promise.all(v.map(val => process(that, val, state)));\n          const xyz = vanillaview(p,v);\n          //xyz[Symbol.for('BANG-VV')] = true;\n          return xyz;\n        } else {\n          const laterFunc = async state => {\n            v = await Promise.all(v.map(val => process(that, val, state)));\n            const xyz = vanillaview(p,v);\n            //xyz[Symbol.for('BANG-VV')] = true;\n            return xyz;\n          };\n          return laterFunc;\n        }\n      }\n\n      function c(p,...v) {\n        return vanillaview(p,v, {useCache:false});\n      }\n\n    // main function (TODO: should we refactor?)\n      function vanillaview(p,v,{useCache:useCache=true}={}) {\n        const retVal = {};\n        let instanceKey, cacheKey;\n\n        v = v.map(guardAndTransformVal);\n\n        if ( useCache ) {\n          ({key:instanceKey} = (v.find(isKey) || {}));\n          cacheKey = p.join('<link rel=join>');\n          const {cached,firstCall} = isCached(cacheKey,v,instanceKey);\n         \n          if ( ! firstCall ) {\n            cached.update(v);\n            return cached;\n          } else {\n            retVal.oldVals = Array.from(v);\n          }\n        } else {\n          retVal.oldVals = Array.from(v);\n        }\n        \n        // compile the template into an updater\n\n        p = [...p]; \n        const vmap = {};\n        const V = v.map(replaceValWithKeyAndOmitInstanceKey(vmap));\n        const externals = [];\n        let str = '';\n\n        while( p.length > 1 ) str += p.shift() + V.shift();\n        str += p.shift();\n\n        const frag = toDOM(str);\n        const walker = document.createTreeWalker(frag, NodeFilter.SHOW_ALL);\n\n        do {\n          makeUpdaters({walker,vmap,externals});\n        } while(walker.nextNode())\n\n        Object.assign(retVal, {\n          externals,\n          v:Object.values(vmap),\n          to,\n          update,\n          code:CODE,\n          nodes:[...frag.childNodes]\n        });\n\n        if ( useCache ) {\n          if ( instanceKey !== undefined ) {\n            cache[cacheKey].instances[instanceKey] = retVal;\n          } else {\n            cache[cacheKey] = retVal;\n          }\n        }\n\n        return retVal;\n      }\n\n\n    // bang integration functions (modified from bang versions)\n      async function process(that, x, state) {\n        if ( typeof x === 'string' ) return x;\n        else \n\n        if ( typeof x === 'number' ) return x+'';\n        else\n\n        if ( typeof x === 'boolean' ) return x+'';\n        else\n\n        if ( x instanceof Date ) return x+'';\n        else\n\n        if ( isUnset(x) ) {\n          if ( that.CONFIG.allowUnset ) return that.CONFIG.unsetPlaceholder || '';\n          else {\n            throw new TypeError(`Value cannot be unset, was: ${x}`);\n          }\n        }\n        else\n\n        if ( x instanceof Promise ) return await process(that, await x.catch(err => err+''), state);\n        else\n\n        if ( x instanceof Element ) return x.outerHTML;\n        else\n\n        if ( x instanceof Node ) return x.textContent;\n\n        const isVVArray   = T.check(T`VanillaViewArray`, x);\n        const isVVK = isKey(x);\n        const isMO    = T.check(T`MarkupObject`, x);\n        const isMAO = T.check(T`MarkupAttrObject`, x);\n        const isVV      = T.check(T`Component`, x);\n        if ( isVVArray || isVVK || isMO || isMAO || isVV ) {\n          return isVVArray ? join(x) : x; // let vanillaview guardAndTransformVal handle\n        }\n        else\n        \n        if ( isIterable(x) ) {\n          // if an Array or iterable is given then\n          // its values are recursively processed via this same function\n          return process(that, (await Promise.all(\n            (\n              await Promise.all(Array.from(x)).catch(e => err+'')\n            ).map(v => process(that, v, state))\n          )), state);\n        }\n\n        else \n\n        if ( Object.getPrototypeOf(x).constructor.name === 'AsyncFunction' ) {\n          return await process(that, await x(state), state);\n        }\n        else\n\n        if ( x instanceof Function ) return x(state);\n        else // it's an object, of some type \n\n        {\n          // State store     \n            /* so we assume an object is state and save it */\n            /* to the global state store */\n            /* which is two-sides so we can find a key */\n            /* given an object. This avoid duplicates */\n          let stateKey;\n\n          // own keys\n            // an object can specify it's own state key\n            // to provide a single logical identity for a piece of state that may\n            // be represented by many objects\n\n          if ( Object.prototype.hasOwnProperty.call(x, that.CONFIG.bangKey) ) {\n            stateKey = new that.StateKey(x[that.CONFIG.bangKey])+'';\n            // in that case, replace the previously saved object with the same logical identity\n            const oldX = that.STATE.get(stateKey);\n            that.STATE.delete(oldX);\n\n            that.STATE.set(stateKey, x);\n            that.STATE.set(x, stateKey);\n          } \n\n          else  /* or the system can come up with a state key */\n\n          {\n            if ( that.STATE.has(x) ) stateKey = that.STATE.get(x);\n            else {\n              stateKey = new that.StateKey()+'';\n              that.STATE.set(stateKey, x);\n              that.STATE.set(x, stateKey);\n            }\n          }\n\n          stateKey += '';\n          return stateKey;\n        }\n      }\n\n      function isIterable(y) {\n        if ( y === null ) return false;\n        return y[Symbol.iterator] instanceof Function;\n      }\n\n      function isUnset(x) {\n        return x === undefined || x === null;\n      }\n\n\n    // to function\n      function to(location, options) {\n        const position = (options || 'replace').toLocaleLowerCase();\n        const frag = document.createDocumentFragment();\n        this.nodes.forEach(n => frag.appendChild(n));\n        const isNode = location instanceof Node;\n        const elem = isNode ? location : document.querySelector(location);\n        try {\n          MOVE[position](frag,elem);\n        } catch(e) {\n          switch(e.constructor && e.constructor.name) {\n            case \"DOMException\":      die({error: INSERT()});             break;\n            case \"TypeError\":         die({error: NOTFOUND(location)});   break; \n            default:                  throw e;\n          }\n        }\n        while(this.externals.length) {\n          this.externals.shift()();\n        }\n      }\n\n    // update functions\n      function makeUpdaters({walker,vmap,externals}) {\n        const node = walker.currentNode;\n        switch( node.nodeType ) {\n          case Node.ELEMENT_NODE:\n            handleElement({node,vmap,externals}); break;\n          case Node.COMMENT_NODE:\n          case Node.TEXT_NODE:\n            handleNode({node,vmap,externals}); break;\n        }\n      }\n\n      function handleNode({node,vmap,externals}) {\n        const lengths = [];\n        const text = node.nodeValue; \n        let result = KEYMATCH.exec(text);\n        while ( result ) {\n          const {index} = result;\n          const key = result[1];\n          const val = vmap[key];\n          const replacer = makeNodeUpdater({node,index,lengths,val});\n          externals.push(() => replacer(val.val));\n          val.replacers.push( replacer );\n          result = KEYMATCH.exec(text);\n        }\n      }\n\n      // node functions\n        function makeNodeUpdater(nodeState) {\n          const {node} = nodeState;\n          const scope = Object.assign({}, nodeState, {\n            oldVal: {length: KEYLEN},\n            oldNodes: [node],\n            lastAnchor: node,\n          });\n          return (newVal) => {\n            if ( scope.oldVal == newVal ) return;\n            scope.val.val = newVal;\n            switch(getType(newVal)) {\n              case \"markupobject\": \n              case \"vanillaviewobject\":\n                handleMarkupInNode(newVal, scope); break;\n              default:\n                handleTextInNode(newVal, scope); break;\n            }\n          };\n        }\n\n        function handleMarkupInNode(newVal, state) {\n          let {oldNodes,lastAnchor} = state;\n          if ( newVal.nodes.length ) {\n            if ( sameOrder(oldNodes,newVal.nodes) ) ; else {\n              {\n                const insertable = [];\n                Array.from(newVal.nodes).forEach(node => {\n                  const inserted = document.contains(node.ownerDocument);\n                  if ( ! inserted ) {\n                    insertable.push(node);\n                  } else {\n                    while( insertable.length ) {\n                      const insertee = insertable.shift();\n                      node.parentNode.insertBefore(insertee, node);\n                    }\n                  }\n                });\n                while ( insertable.length ) {\n                  const insertee = insertable.shift();\n                  lastAnchor.parentNode.insertBefore(insertee,lastAnchor);\n                }\n                //state.lastAnchor = newVal.nodes[0];\n              }\n            }\n          } else {\n            const placeholderNode = summonPlaceholder(lastAnchor);\n            lastAnchor.parentNode.insertBefore(placeholderNode,lastAnchor.nextSibling);\n            state.lastAnchor = placeholderNode;\n          }\n          // MARK: Unbond event might be relevant here.\n          // if nodes are not included we can just remove them\n          const dn = diffNodes(oldNodes,newVal.nodes);\n          if ( dn.size ) {\n            const f = document.createDocumentFragment();\n            dn.forEach(n => f.appendChild(n));\n          }\n          state.oldNodes = newVal.nodes || [lastAnchor];\n          while ( newVal.externals.length ) {\n            const func = newVal.externals.shift();\n            func();\n          } \n        }\n\n        function sameOrder(nodesA, nodesB) {\n          if ( nodesA.length != nodesB.length ) return false;\n\n          return Array.from(nodesA).every((an,i) => an == nodesB[i]);\n        }\n\n        function handleTextInNode(newVal, state) {\n          let {oldVal, index, val, lengths, node} = state;\n\n          const valIndex = val.vi;\n          const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n          const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n          const value = node.nodeValue;\n\n          lengths[valIndex] = newVal.length;\n\n          const correction = lengthBefore-originalLengthBefore;\n          const before = value.slice(0,index+correction);\n          const after = value.slice(index+correction+oldVal.length);\n\n          const newValue = before + newVal + after;\n\n          node.nodeValue = newValue;\n\n          if ( node.linkedCustomElement && newValue.match(/state[\\s\\S]*=/gm) ) {\n            node.linkedCustomElement.setAttribute('state', newVal);\n          }\n\n          state.oldVal = newVal;\n        }\n\n      // element attribute functions\n        function handleElement({node,vmap,externals}) {\n          getAttributes(node).forEach(({name,value} = {}) => {\n            const attrState = {node, vmap, externals, name, lengths: []};\n\n            KEYMATCH.lastIndex = 0;\n            let result = KEYMATCH.exec(name);\n            while( result ) {\n              prepareAttributeUpdater(result, attrState, {updateName:true});\n              result = KEYMATCH.exec(name);\n            }\n\n            KEYMATCH.lastIndex = 0;\n            result = KEYMATCH.exec(value);\n            while( result ) {\n              prepareAttributeUpdater(result, attrState, {updateName:false});\n              result = KEYMATCH.exec(value);\n            }\n          });\n        }\n\n        function prepareAttributeUpdater(result, attrState, {updateName}) {\n          const {index, input} = result;\n          const scope = Object.assign({}, attrState, {\n            index, input, updateName, \n            val: attrState.vmap[result[1]],\n            oldVal: {length: KEYLEN},\n            oldName: attrState.name,\n          });\n\n          let replacer;\n          if ( updateName ) {\n            replacer = makeAttributeNameUpdater(scope);\n          } else {\n            replacer = makeAttributeValueUpdater(scope);\n          }\n\n          scope.externals.push(() => replacer(scope.val.val));\n          scope.val.replacers.push( replacer );\n        }\n\n        // FIXME: needs to support multiple replacements just like value\n        // QUESTION: why is the variable oldName so required here, why can't we call it oldVal?\n        // if we do it breaks, WHY?\n        function makeAttributeNameUpdater(scope) {\n          let {oldName,node,val} = scope;\n          return (newVal) => {\n            if ( oldName == newVal ) return;\n            val.val = newVal;\n            const attr = node.hasAttribute(oldName) ? oldName : '';\n            if ( attr !== newVal ) {\n              if ( attr ) {\n                node.removeAttribute(oldName);\n                node[oldName] = undefined;\n              }\n              if ( newVal ) {\n                newVal = newVal.trim();\n\n                let name = newVal, value = undefined;\n\n                if( ATTRMATCH.test(newVal) ) {\n                  const assignmentIndex = newVal.indexOf('='); \n                  ([name,value] = [newVal.slice(0,assignmentIndex), newVal.slice(assignmentIndex+1)]);\n                }\n\n                reliablySetAttribute(node, name, value);\n              }\n              oldName = newVal;\n            }\n          };\n        }\n\n        function makeAttributeValueUpdater(scope) {\n          const updater = (newVal) => {\n            if ( scope.oldVal == newVal ) return;\n            scope.val.val = newVal;\n            switch(getType(newVal)) {\n              case \"funcarray\":       updateAttrWithFuncarrayValue(newVal, scope); break;\n              case \"function\":        updateAttrWithFunctionValue(newVal, scope); break;\n              case \"handlers\":        updateAttrWithHandlersValue(newVal, scope); break;\n              case \"markupobject\":     \n              case \"vanillaviewobject\": \n                newVal = nodesToStr(newVal.nodes); \n                updateAttrWithTextValue(newVal, scope); break;\n              /* eslint-disable no-fallthrough */\n              case \"markupattrobject\":  // deliberate fall through\n                newVal = newVal.str;\n              default:                \n                updateAttrWithTextValue(newVal, scope); break;\n              /* eslint-enable no-fallthrough */\n            }\n          };\n          // call it the first time so it loads well\n          // and we elide out the key placeholders here\n          updater(scope.val.val);\n          return updater;\n        }\n\n    // helpers\n      function getAttributes(node) {\n        if ( ! node.hasAttribute ) return [];\n\n        // for parity with classList.add (which trims whitespace)\n          // otherwise once the classList manipulation happens\n          // our indexes for replacement will be off\n        if ( node.hasAttribute('class') ) {\n          node.setAttribute('class', formatClassListValue(node.getAttribute('class')));\n        }\n        if ( !! node.attributes && Number.isInteger(node.attributes.length) ) return Array.from(node.attributes);\n        const attrs = [];\n        for ( const name of node ) {\n          if ( node.hasAttribute(name) ) {\n            attrs.push({name, value:node.getAttribute(name)});\n          }\n        }\n        return attrs;\n      }\n\n      function updateAttrWithFunctionValue(newVal, scope) {\n        let {oldVal,node,name,externals} = scope;\n        if ( name !== 'bond' ) {\n          let flags = {};\n          if ( name.includes(':') ) {\n            ([name, ...flags] = name.split(':'));\n            flags = flags.reduce((O,f) => {\n              O[f] = true;\n              return O;\n            }, {});\n          }\n          if ( oldVal ) {\n            node.removeEventListener(name, oldVal, flags);\n          }\n          node.addEventListener(name, newVal, flags); \n          reliablySetAttribute(node, name, '');\n        } else {\n          if ( oldVal ) {\n            const index = externals.indexOf(oldVal);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          }\n          externals.push(() => newVal(node)); \n        }\n        scope.oldVal = newVal;\n      }\n\n      function updateAttrWithFuncarrayValue(newVal, scope) {\n        let {oldVal,node,name,externals} = scope;\n        if ( oldVal && ! Array.isArray(oldVal) ) {\n          oldVal = [oldVal]; \n        }\n        if ( name !== 'bond' ) {\n          let flags = {};\n          if ( name.includes(':') ) {\n            ([name, ...flags] = name.split(':'));\n            flags = flags.reduce((O,f) => {\n              O[f] = true;\n              return O;\n            }, {});\n          }\n          if ( oldVal ) {\n            oldVal.forEach(of => node.removeEventListener(name, of, flags));\n          }\n          newVal.forEach(f => node.addEventListener(name, f, flags));\n        } else {\n          if ( oldVal ) {\n            oldVal.forEach(of => {\n              const index = externals.indexOf(of);\n              if ( index >= 0 ) {\n                externals.splice(index,1);\n              }\n            });\n          }\n          newVal.forEach(f => externals.push(() => f(node)));\n        }\n        scope.oldVal = newVal;\n      }\n\n      function updateAttrWithHandlersValue(newVal, scope) {\n        let {oldVal,node,externals,} = scope;\n        if ( !!oldVal && T.check(T`Handlers`, oldVal) ) {\n          Object.entries(oldVal).forEach(([eventName,funcVal]) => {\n            if ( eventName !== 'bond' ) {\n              let flags = {};\n              if ( eventName.includes(':') ) {\n                ([eventName, ...flags] = eventName.split(':'));\n                flags = flags.reduce((O,f) => {\n                  O[f] = true;\n                  return O;\n                }, {});\n              }\n              console.log(eventName, funcVal, flags);\n              node.removeEventListener(eventName, funcVal, flags); \n            } else {\n              const index = externals.indexOf(funcVal);\n              if ( index >= 0 ) {\n                externals.splice(index,1);\n              }\n            }\n          });\n        }\n        Object.entries(newVal).forEach(([eventName,funcVal]) => {\n          if ( eventName !== 'bond' ) {\n            let flags = {};\n            if ( eventName.includes(':') ) {\n              ([eventName, ...flags] = eventName.split(':'));\n              flags = flags.reduce((O,f) => {\n                O[f] = true;\n                return O;\n              }, {});\n            }\n            node.addEventListener(eventName, funcVal, flags); \n          } else {\n            externals.push(() => funcVal(node)); \n          }\n        });\n        scope.oldVal = newVal;\n      }\n\n      function updateAttrWithTextValue(newVal, scope) {\n        let {oldVal,node,index,name,val,lengths} = scope;\n        let zeroWidthCorrection = 0;\n        const valIndex = val.vi;\n        const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n          \n        // we need to trim newVal to have parity with classlist add\n          // the reason we have zeroWidthCorrection = -1\n          // is because the classList is a set of non-zero width tokens\n          // separated by spaces\n          // when we have a zero width token, we have two adjacent spaces\n          // which, by virtue of our other requirement, gets replaced by a single space\n          // effectively elliding out our replacement location\n          // in order to keep our replacement location in tact\n          // we need to compensate for the loss of a token slot (effectively a token + a space)\n          // and having a -1 correction effectively does this.\n        if ( name == \"class\" ) {\n          newVal = newVal.trim();\n          if ( newVal.length == 0 ) {\n            zeroWidthCorrection = -1;\n          }\n          scope.val.val = newVal;\n        }\n        lengths[valIndex] = newVal.length + zeroWidthCorrection;\n        let attr = node.getAttribute(name);\n\n        const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n\n        const correction = lengthBefore-originalLengthBefore;\n        const before = attr.slice(0,index+correction);\n        const after = attr.slice(index+correction+oldVal.length);\n\n        let newAttrValue;\n        \n        if ( name == \"class\" ) {\n          const spacer = oldVal.length == 0 ? ' ' : '';\n          newAttrValue = before + spacer + newVal + spacer + after;\n        } else {\n          newAttrValue = before + newVal + after;\n        }\n\n        reliablySetAttribute(node, name, newAttrValue);\n\n        scope.oldVal = newVal;\n      }\n\n      function reliablySetAttribute(node, name, value ) {\n        if (  name == \"class\" ) {\n          value = formatClassListValue(value);\n        }\n\n        try {\n          node.setAttribute(name,value);\n        } catch(e) {\n        }\n\n        try {\n          node[name] = value == undefined ? true : value;\n        } catch(e) {\n        }\n      }\n\n      function getType(val) {\n        const type = T.check(T`Function`, val) ? 'function' :\n          T.check(T`Handlers`, val) ? 'handlers' : \n          T.check(T`VanillaViewObject`, val) ? 'vanillaviewobject' : \n          T.check(T`MarkupObject`, val) ? 'markupobject' :\n          T.check(T`MarkupAttrObject`, val) ? 'markupattrobject' :\n          T.check(T`VanillaViewArray`, val) ? 'vanillaviewarray' : \n          T.check(T`FuncArray`, val) ? 'funcarray' : \n          'default'\n        ;\n        return type;\n      }\n\n      function summonPlaceholder(sibling) {\n        let ph = [...sibling.parentNode.childNodes].find(\n          node => node.nodeType == Node.COMMENT_NODE && node.nodeValue == 'vanillaview_placeholder' );\n        if ( ! ph ) {\n          ph = toDOM(`<!--vanillaview_placeholder-->`).firstChild;\n        }\n        return ph;\n      }\n\n      // cache helpers\n        // FIXME: function needs refactor\n        function isCached(cacheKey,v,instanceKey) {\n          let firstCall;\n          let cached = cache[cacheKey];\n          if ( cached == undefined ) {\n            cached = cache[cacheKey] = {};\n            if ( instanceKey !== undefined ) {\n              cached.instances = {};\n              cached = cached.instances[instanceKey] = {};\n            }\n            firstCall = true;\n          } else {\n            if ( instanceKey !== undefined ) {\n              if ( ! cached.instances ) {\n                cached.instances = {};\n                firstCall = true;\n              } else {\n                cached = cached.instances[instanceKey];\n                if ( ! cached ) {\n                  firstCall = true;\n                } else {\n                  firstCall = false;\n                }\n              }\n            } else {\n              firstCall = false;\n            }\n          }\n          return {cached,firstCall};\n        }\n\n      // Markup helpers\n        // Returns an object that VanillaView treats as markup,\n        // even tho it is NOT a VanillaView Object (defined with R/X/$)\n        // And even tho it is in the location of a template value replacement\n        // Which would normally be the treated as String\n        function markup(str) {\n          str = T.check(T`None`, str) ? '' : str; \n          const frag = toDOM(str);\n          const retVal = {\n            type: 'MarkupObject',\n            code:CODE,\n            nodes:[...frag.childNodes],\n            externals: []\n          };\n          return retVal;\n        }\n\n        // Returns an object that VanillaView treats, again, as markup\n        // But this time markup that is OKAY to have within a quoted attribute\n        function attrmarkup(str) {\n          str = T.check(T`None`, str) ? '' : str; \n          str = str.replace(/\"/g,'&quot;');\n          const retVal = {\n            type: 'MarkupAttrObject',\n            code: CODE,\n            str\n          };\n          return retVal;\n        }\n\n        function guardEmptyHandlers(val) {\n          if ( Array.isArray(val) ) {\n            if ( val.length == 0 ) {\n              return [NULLFUNC]\n            } \n            return val;\n          } else {\n            if ( T.check(T`None`, val) ) {\n              return NULLFUNC;\n            }\n          }\n        }\n\n      // other helpers\n        function formatClassListValue(value) {\n          value = value.trim();\n          value = value.replace(/\\s+/g, ' ');\n          return value;\n        }\n\n        function replaceValWithKeyAndOmitInstanceKey(vmap) {\n          return (val,vi) => {\n            // omit instance key\n            if ( T.check(T`Key`, val) ) {\n              return '';\n            }\n            const key = ('key'+Math.random()).replace('.','').padEnd(KEYLEN,'0').slice(0,KEYLEN);\n            let k = key;\n            if ( T.check(T`VanillaViewObject`, val) || T.check(T`MarkupObject`, val) ) {\n              k = `<!--${k}-->`;\n            }\n            vmap[key.trim()] = {vi,val,replacers:[]};\n            return k;\n          };\n        }\n\n        function toDOM(str) {\n          const templateEl = (new DOMParser).parseFromString(\n            `<template>${str}</template>`,\"text/html\"\n          ).head.firstElementChild;\n          let f;\n          if ( templateEl instanceof HTMLTemplateElement ) { \n            f = templateEl.content;\n            f.normalize();\n            return f;\n          } else {\n            throw new TypeError(`Could not find template element after parsing string to DOM:\\n=START=\\n${str}\\n=END=`);\n          }\n        }\n\n        function guardAndTransformVal(v) {\n          const isFunc          = T.check(T`Function`, v);\n          const isUnset         = T.check(T`None`, v);\n          const isObject        = T.check(T`Object`, v);\n          const isVanillaViewArray   = T.check(T`VanillaViewArray`, v);\n          const isFuncArray     = T.check(T`FuncArray`, v);\n          const isMarkupObject    = T.check(T`MarkupObject`, v);\n          const isMarkupAttrObject= T.check(T`MarkupAttrObject`, v);\n          const isVanillaView        = T.check(T`VanillaViewObject`, v);\n          const isForgery       = T.check(T`VanillaViewLikeObject`, v)  && !isVanillaView; \n\n          if ( isFunc )             return v;\n          if ( isVanillaView )           return v;\n          if ( isKey(v) )           return v;\n          if ( isHandlers(v) )      return v;\n          if ( isVanillaViewArray )      return join(v); \n          if ( isFuncArray )        return v;\n          if ( isMarkupObject )     return v;\n          if ( isMarkupAttrObject)  return v;\n\n          if ( isUnset )            die({error: UNSET()});\n          if ( isForgery )          die({error: XSS()});\n\n          if ( isObject )       {\n            if ( Object.keys(v).join(',') === \"key\" ) {\n              die({error: KEY(v)});    \n            } else die({error: OBJ()});\n          }\n\n          return v+'';\n        }\n\n        function join(os) {\n          const externals = [];\n          const bigNodes = [];\n          const v = [];\n          const oldVals = [];\n          os.forEach(o => {\n            //v.push(...o.v); \n            //oldVals.push(...o.oldVals);\n            externals.push(...o.externals);\n            bigNodes.push(...o.nodes);\n          });\n          const retVal = {v,code:CODE,oldVals,nodes:bigNodes,to,update,externals};\n          return retVal;\n        }\n\n        function nodesToStr(nodes) {\n          const frag = document.createDocumentFragment();\n          nodes.forEach(n => frag.appendChild(n.cloneNode(true)));\n          const container = document.createElement('body');\n          container.appendChild(frag);\n          return container.innerHTML;\n        }\n\n        function diffNodes(last,next) {\n          last = new Set(last);\n          next = new Set(next);\n          return new Set([...last].filter(n => !next.has(n)));\n        }\n\n        function update(newVals) {\n          const updateable = this.v.filter(({vi}) => didChange(newVals[vi], this.oldVals[vi]));\n          updateable.forEach(({vi,replacers}) => replacers.forEach(f => f(newVals[vi])));\n          this.oldVals = Array.from(newVals);\n        }\n\n        function didChange(oldVal, newVal) {\n          const [oldType, newType] = [oldVal, newVal].map(getType); \n          let ret;\n          if ( oldType != newType ) {\n            ret =  true;\n          } else {\n            switch(oldType) {\n              case \"vanillaviewobject\":\n                // the vanillaview object is returned by a view function\n                // which has already called its updaters and checked its slot values\n                // to determine and show changes\n                // except in the case of a list of nodes\n                ret = true;\n                break;\n              /* eslint-disable no-fallthrough */\n              case \"funcarray\":\n              case \"function\":\n                // hard to equate even if same str value as scope could be diff\n                ret = true;\n                break;\n              case \"vanillaviewarray\":\n                // need to do array dif so don't do here\n                ret = true;\n                break;\n              case \"markupattrobject\":\n              case \"markupobject\":\n                // need to check multiple things\n                ret = true;\n                break;\n              default:\n                ret = JSON.stringify(oldVal) !== JSON.stringify(newVal);\n                break;\n              /* eslint-enable no-fallthrough */\n            }\n          }\n          return ret;\n        }\n\n    // reporting and error helpers \n      function die(msg,err) {\n        msg.stack = (new Error()).stack.split(/\\s*\\n\\s*/g);\n        throw JSON.stringify(msg,null,2);\n      }\n\n      function say(msg) {\n      }\n\n  exports.c = c;\n  exports.s = s;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n{\n  // constants, classes, config and state\n    const DEBUG = false;\n    const LEGACY = false;\n    const MOBILE = isMobile();\n    const DOUBLE_BARREL = /\\w+-\\w*/; // note that this matches triple- and higher barrels, too\n    const F = _FUNC; \n    const FUNC_CALL = /\\);?$/;\n    const CONFIG = {\n      htmlFile: 'markup.html',\n      scriptFile: 'script.js',\n      styleFile: 'style.css',\n      bangKey: '_bang_key',\n      componentsPath: './components',\n      allowUnset: false,\n      unsetPlaceholder: '',\n      EVENTS: `error load click pointerdown pointerup pointermove mousedown mouseup \n        mousemove touchstart touchend touchmove touchcancel dblclick dragstart dragend \n        dragmove drag mouseover mouseout focus blur focusin focusout scroll\n      `.split(/\\s+/g).filter(s => s.length).map(e => `on${e}`),\n      delayFirstPaintUntilLoaded: true,\n      noHandlerPassthrough: false\n    };\n    const STATE = new Map();\n    const CACHE = new Map();\n    const Started = new Set();\n    const TRANSFORMING = new WeakSet();\n    const Dependents = new Map();\n    const Counts = {\n      started: 0,\n      finished: 0\n    };\n    const OBSERVE_OPTS = {subtree: true, childList: true, characterData: true};\n    let observer; // global mutation observer\n    let systemKeys = 1;\n    let _c$;\n\n    const BangBase = (name) => class Base extends HTMLElement {\n      static #activeAttrs = ['state']; // we listen for changes to these attributes only\n      static get observedAttributes() {\n        return Array.from(Base.#activeAttrs);\n      }\n      #name = name;\n\n      constructor() {\n        super();\n        DEBUG && say('log',name, 'constructed');\n        this.print();\n      }\n\n      // BANG! API methods\n      print() {\n        Counts.started++;\n        this.prepareVisibility();\n        const state = this.handleAttrs(this.attributes, {originals: true});\n        return this.printShadow(state);\n      }\n\n      prepareVisibility() {\n        this.classList.add('bang-el');\n        this.classList.remove('bang-styled');\n        // this is like an onerror event for stylesheet's \n          // we do this because we want to display elements if they have no stylesheet defined\n          // becuase it's reasonabgle to want to not include a stylesheet with your custom element\n        fetchStyle(name).catch(err => this.setVisible());\n      }\n\n      setVisible() {\n        this.classList.add('bang-styled');\n      }\n\n      // Web Components methods\n      attributeChangedCallback(name, oldValue, value) {\n        // setting the state attribute casues the custom element to re-render\n        if ( name === 'state' && !isUnset(oldValue) ) {\n          DEBUG && say('log',`Changing state, so calling print.`, oldValue, value, this);\n          this.print();\n        }\n      }\n\n      connectedCallback() {\n        say('log',name, 'connected');\n      }\n\n      // private methods\n      handleAttrs(attrs, {node, originals} = {}) {\n        let state;\n\n        if ( ! node ) node = this;\n\n        for( let {name,value} of attrs ) {\n          if ( isUnset(value) ) continue;\n\n          if ( name === 'state' ) {\n            const stateKey = value; \n            const stateObject = STATE.get(stateKey);\n            \n            if ( isUnset(stateObject) ) {\n              throw new TypeError(`\n                <${name}> constructor passed state key ${stateKey} which is unset. It must be set.\n              `);\n            }\n            \n            state = stateObject;\n            \n            if ( originals ) {\n              let acquirers = Dependents.get(stateKey);\n              if ( ! acquirers ) {\n                acquirers = new Set();\n                Dependents.set(stateKey, acquirers);\n              }\n              acquirers.add(node);\n            }\n          } else if ( originals ) { // set event handlers to custom element class instance methods\n            if ( ! name.startsWith('on') ) continue;\n            value = value.trim();\n            if ( ! value ) continue;\n\n            const path = node === this ? 'this.' : 'this.getRootNode().host.';\n            if ( value.startsWith(path) ) continue;\n            const ender = value.match(FUNC_CALL) ? '' : '(event)';\n            node.setAttribute(name, `${path}${value}${ender}`);\n          }\n        }\n\n        return state;\n      }\n\n      printShadow(state) {\n        return fetchMarkup(this.#name, this).then(async markup => {\n          const cooked = await cook.call(this, markup, state);\n          if ( LEGACY ) {\n            const nodes = toDOM(cooked);\n            // attributes on each node in the shadom DOM that has an even handler or state\n            const listening = nodes.querySelectorAll(CONFIG.EVENTS.map(e => `[${e}]`).join(', '));\n            listening.forEach(node => this.handleAttrs(node.attributes, {node, originals: true}));\n            DEBUG && say('log',nodes, cooked, state);\n            if ( this.shadowRoot ) {\n              this.shadowRoot.replaceChildren(nodes);\n            } else {\n              const shadow = this.attachShadow({mode:'open'});\n              console.log({observer});\n              observer.observe(shadow, OBSERVE_OPTS);\n              shadow.replaceChildren(nodes);\n           }\n          } else {\n            if ( this.shadowRoot ) {\n              //this.shadowRoot.replaceChildren(nodes);\n            } else {\n              const shadow = this.attachShadow({mode:'open'});\n              //console.log({observer});\n              observer.observe(shadow, OBSERVE_OPTS);\n              cooked.to(shadow, 'insert');\n              const listening = shadow.querySelectorAll(CONFIG.EVENTS.map(e => `[${e}]`).join(', '));\n              listening.forEach(node => this.handleAttrs(node.attributes, {node, originals: true}));\n            }\n          }\n        })\n        .catch(err => DEBUG && say('warn',err))\n        .finally(() => Counts.finished++);\n      }\n    };\n\n    class StateKey extends String {\n      constructor (keyNumber) {\n        if ( keyNumber == undefined ) super(`system-key:${systemKeys++}`); \n        else super(`client-key:${keyNumber}`);\n      }\n    }\n\n  install();\n\n  // API\n    async function use(name) {\n      let component;\n      await fetchScript(name)\n        .then(script => { // if there's a script that extends base, evaluate it to be component\n          const Base = BangBase(name);\n          const Compose = `(function () { ${Base.toString()}; return ${script}; }())`;\n          try {\n            component = eval(Compose);\n          } catch(e) {\n            DEBUG && say('warn',e, Compose, component)\n          }\n        }).catch(() => {  // otherwise if there is no such extension script, just use the Base class\n          component = BangBase(name);\n        });\n      \n      self.customElements.define(name, component);\n      DEBUG && self.customElements.whenDefined(name).then(obj => say('log',name, 'defined', obj));\n    }\n\n    function bangfig(newConfig = {}) {\n      Object.assign(CONFIG, newConfig);\n    }\n\n    function setState(key, state, rerenderAll = false) {\n      STATE.set(key, state);\n      STATE.set(state, key);\n\n      if ( document.body && rerenderAll ) { // re-render all very simply\n        // we need to remove styled because it will need to load after we set the innerHTML\n        Array.from(document.querySelectorAll(':not(body).bang-styled'))\n          .forEach(node => node.classList.remove('bang-styled'));\n        \n        const HTML = document.body.innerHTML;\n        document.body.innerHTML = '';\n        document.body.innerHTML = HTML;\n      } else { // re-render only those components depending on that key\n        const acquirers = Dependents.get(key);\n        if ( acquirers ) acquirers.forEach(host => host.print());\n      }\n    }\n\n    function cloneState(key) {\n      if ( STATE.has(key) ) return JSON.parse(JSON.stringify(STATE.get(key)));\n      else {\n        throw new TypeError(`State store does not have the key ${key}`);\n      }\n    }\n\n    async function loaded() {\n      const loadCheck = () => {\n        const nonZeroCount = Counts.started > 0; \n        const finishedWhatWeStarted = Counts.finished === Counts.started;\n        return nonZeroCount && finishedWhatWeStarted;\n      };\n      return becomesTrue(loadCheck);\n    }\n\n    async function bangLoaded() {\n      const loadCheck = () => {\n        const c_defined = typeof _c$ === \"function\";\n        return c_defined;\n      };\n      return becomesTrue(loadCheck);\n    }\n\n  // helpers\n    async function install() {\n      Object.assign(globalThis, {\n        use, setState, cloneState, loaded, sleep, bangfig, bangLoaded, isMobile,\n        ...( DEBUG ? { STATE, CACHE, TRANSFORMING, Started, BangBase } : {})\n      });\n\n      const module = globalThis.vanillaview || (await __webpack_require__.e(/*! import() */ \"src_vv_vanillaview_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./vv/vanillaview.js */ \"./src/vv/vanillaview.js\")));\n      const {s} = module;\n      const That = {STATE,CONFIG,StateKey}; \n      _c$ = s.bind(That);\n      That._c$ = _c$;\n\n      if ( CONFIG.delayFirstPaintUntilLoaded ) {\n        becomesTrue(() => document.body).then(() => document.body.classList.add('bang-el'));\n      }\n\n      observer = new MutationObserver(transformBangs);\n      /* we are interested in bang nodes (which start as comments) */\n      observer.observe(document, OBSERVE_OPTS);\n      findBangs(transformBang); \n      \n      loaded().then(() => document.body.classList.add('bang-styled'));\n    }\n\n    async function fetchMarkup(name, comp) {\n      // cache first\n        // we make any subsequent calls for name wait for the first call to complete\n        // otherwise we create many in parallel without benefitting from caching\n\n      const key = `markup:${name}`;\n\n      if ( Started.has(key) ) {\n        if ( ! CACHE.has(key) ) await becomesTrue(() => CACHE.has(key));\n      } else Started.add(key);\n\n      const styleKey = `style${name}`;\n      const baseUrl = `${CONFIG.componentsPath}/${name}`;\n      if ( CACHE.has(key) ) {\n        const markup = CACHE.get(key);\n        if ( CACHE.get(styleKey) instanceof Error ) comp.setVisible();\n        \n        // if there is an error style and we are still includig that link\n        // we generate and cache the markup again to omit such a link element\n        if ( CACHE.get(styleKey) instanceof Error && markup.includes(`href=${baseUrl}/${CONFIG.styleFile}`) ) {\n          // then we need to set the cache for markup again and remove the link to the stylesheet which failed \n        } else {\n          comp.setVisible();\n          return markup;\n        }\n      }\n      \n      const markupUrl = `${baseUrl}/${CONFIG.htmlFile}`;\n      let resp;\n      const markupText = await fetch(markupUrl).then(async r => { \n        let text = '';\n        if ( r.ok ) text = await r.text();\n        else text = `<slot></slot>`;        // if no markup is given we just insert all content within the custom element\n      \n        if ( CACHE.get(styleKey) instanceof Error ) { \n          resp = text; \n          comp.setVisible();\n        } else {\n          // inlining styles for increase speed */\n            // we setVisible (add bang-styled) straight away because the inline styles block the markup\n            // so no FOUC while stylesheet link is loading, like previously: resp = `\n            // <link rel=stylesheet href=${baseUrl}/${CONFIG.styleFile} onload=setVisible>${text}`;\n          resp = `<style>${await fetchStyle(name).catch(e => '')}</style>${text}`;\n          comp.setVisible();\n        }\n        \n        return resp;\n      }).finally(async () => CACHE.set(key, await resp));\n      return markupText;\n    }\n\n    async function fetchFile(name, file) {\n      const key = `${file}:${name}`;\n\n      if ( Started.has(key) ) {\n        if ( ! CACHE.has(key) ) await becomesTrue(() => CACHE.has(key));\n      } else Started.add(key);\n\n      if ( CACHE.has(key) ) return CACHE.get(key);\n\n      const url = `${CONFIG.componentsPath}/${name}/${file}`;\n      let resp;\n      const fileText = await fetch(url).then(r => { \n        if ( r.ok ) {\n          resp = r.text();\n          return resp;\n        } \n        resp = new TypeError(`Fetch error: ${url}, ${r.statusText}`);\n        throw resp;\n      }).finally(async () => CACHE.set(key, await resp));\n      \n      return fileText;\n    }\n\n    async function fetchStyle(name) {\n      return fetchFile(name, CONFIG.styleFile);\n    }\n\n    async function fetchScript(name) {\n      return fetchFile(name, CONFIG.scriptFile);\n    }\n\n    // search and transform each added subtree\n    function transformBangs(records) {\n      records.forEach(record => {\n        DEBUG && say('log',record);\n        const {addedNodes} = record;\n        if ( !addedNodes ) return;\n        addedNodes.forEach(node => findBangs(transformBang, node));\n      });\n    }\n\n    function transformBang(current) {\n      DEBUG && say('log',{transformBang},{current});\n      const [name, data] = getBangDetails(current);\n      DEBUG && say('log',{name, data});\n\n      // replace the bang node (comment) with its actual custom element node\n      const actualElement = createElement(name, data);\n      current.linkedCustomElement = actualElement;\n      current.parentNode.replaceChild(actualElement, current);\n    }\n\n    function findBangs(callback, root = document.documentElement) {\n      const Acceptor = {\n        acceptNode(node) {\n          if ( node.nodeType !== Node.COMMENT_NODE ) return NodeFilter.FILTER_SKIP;\n          const [name] = getBangDetails(node); \n          if ( name.match(DOUBLE_BARREL) ) return NodeFilter.FILTER_ACCEPT;\n          else return NodeFilter.FILTER_REJECT;\n        }\n      };\n      const iterator = document.createTreeWalker(root, NodeFilter.SHOW_COMMENT, Acceptor);\n      const replacements = [];\n\n      // handle root node\n        // it's a special case because it will be present in the iteration even if\n        // the NodeFilter would filter it out if it were not the root\n      let current = iterator.currentNode;\n\n      if ( Acceptor.acceptNode(current) === NodeFilter.FILTER_ACCEPT ) {\n        if ( !TRANSFORMING.has(current) ) {\n          TRANSFORMING.add(current);\n          const target = current;\n          replacements.push(() => transformBang(target));\n        }\n      }\n\n      // handle any descendents\n        while (true) {\n          current = iterator.nextNode();\n          if ( ! current ) break;\n\n          if ( !TRANSFORMING.has(current) ) {\n            TRANSFORMING.add(current);\n            const target = current;\n            replacements.push(() => transformBang(target));\n          }\n        }\n\n      while(replacements.length) replacements.pop()();\n    }\n\n    function getBangDetails(node) {\n      const text = node.textContent.trim();\n      const [name, ...data] = text.split(/[\\s\\t]/g);\n      return [name, data.join(' ')];\n    }\n\n    async function process(x, state) {\n      if ( typeof x === 'string' ) return x;\n      else \n\n      if ( typeof x === 'number' ) return x+'';\n      else\n\n      if ( typeof x === 'boolean' ) return x+'';\n      else\n\n      if ( x instanceof Date ) return x+'';\n      else\n\n      if ( isUnset(x) ) {\n        if ( CONFIG.allowUnset ) return CONFIG.unsetPlaceholder || '';\n        else {\n          throw new TypeError(`Value cannot be unset, was: ${x}`);\n        }\n      }\n      else\n\n      if ( x instanceof Promise ) return await x.catch(err => err+'');\n      else\n\n      if ( x instanceof Element ) return x.outerHTML;\n      else\n\n      if ( x instanceof Node ) return x.textContent;\n      else\n\n      if ( isIterable(x) ) {\n        // if an Array or iterable is given then\n        // its values are recursively processed via this same function\n        return (await Promise.all(\n          (\n            await Promise.all(Array.from(x)).catch(e => err+'')\n          ).map(v => process(v, state))\n        )).join(' ');\n      }\n      else\n\n      if ( Object.getPrototypeOf(x).constructor.name === 'AsyncFunction' ) return await x(state);\n      else\n\n      if ( x instanceof Function ) return x(state);\n      else // it's an object, of some type \n\n      {\n        // State store     \n          /* so we assume an object is state and save it */\n          /* to the global state store */\n          /* which is two-sides so we can find a key */\n          /* given an object. This avoid duplicates */\n        let stateKey;\n\n        // own keys\n          // an object can specify it's own state key\n          // to provide a single logical identity for a piece of state that may\n          // be represented by many objects\n\n        if ( Object.prototype.hasOwnProperty.call(x, CONFIG.bangKey) ) {\n          stateKey = new StateKey(x[CONFIG.bangKey])+'';\n          // in that case, replace the previously saved object with the same logical identity\n          const oldX = STATE.get(stateKey);\n          STATE.delete(oldX);\n\n          STATE.set(stateKey, x);\n          STATE.set(x, stateKey);\n        } \n\n        else  /* or the system can come up with a state key */\n\n        {\n          if ( STATE.has(x) ) stateKey = STATE.get(x);\n          else {\n            stateKey = new StateKey()+'';\n            STATE.set(stateKey, x);\n            STATE.set(x, stateKey);\n          }\n        }\n\n        stateKey += '';\n        DEBUG && say('log',{stateKey});\n        return stateKey;\n      }\n    }\n\n    async function cook(markup, state) {\n      let cooked = '';\n      try {\n        if ( !Object.prototype.hasOwnProperty.call(state, '_self') ) {\n          Object.defineProperty(state, '_self', {\n            get: () => state\n          });\n        }\n        DEBUG && say('log','_self', state._self);\n      } catch(e) {\n        DEBUG && say('warn',\n          `Cannot add '_self' self-reference property to state. \n            This enables a component to inspect the top-level state object it is passed.`\n        );\n      }\n      try {\n        with(state) {\n          cooked = await eval(\"(async function () { return await _FUNC`${{state}}\"+markup+\"`; }())\");  \n        }\n        DEBUG && console.log({cooked});\n        return cooked;\n      } catch(error) {\n        say('error', 'Template error', {markup, state, error});\n        throw error;\n      }\n    }\n\n    async function _FUNC(strings, ...vals) {\n      const s = Array.from(strings);\n      const ret =  await _c$(s, ...vals);\n      return ret;\n    }\n\n    async function old_FUNC(strings, ...vals) {\n      const s = Array.from(strings);\n      let SystemCall = false;\n      let state;\n      let str = '';\n\n      DEBUG && say('log',s.join('${}'));\n\n      if ( s[0].length === 0 && vals[0].state ) {\n        // by convention (see how we construct the template that we tag with FUNC)\n        // the first value is the state object when our system calls it\n        SystemCall = true;\n      }\n\n      // resolve all the values now if it's a SystemCall of _FUNC\n      if ( SystemCall ) {\n        const {state} = vals.shift();\n        s.shift();\n        vals = await Promise.all(vals.map(v => process(v, state)));\n        DEBUG && say('log','System _FUNC call: ' + vals.join(', '));\n\n        while(s.length) {\n          str += s.shift();\n          if ( vals.length ) {\n            str += vals.shift();\n          }\n        }\n        return str;\n      } \n\n      else \n\n      // otherwise resolve them when we have access to the top-level state\n        // this is effectively just a little bit of magic that lets us \"overload\"\n        // the method signature of F\n\n      return async state => {\n        vals = await Promise.all(vals.map(v => process(v, state)));\n        DEBUG && say('log','in-template _FUNC call:' + vals.join(', '));\n\n        while(s.length) {\n          str += s.shift();\n          if ( vals.length ) str += vals.shift();\n        }\n\n        return str;\n      };\n    }\n\n    function createElement(name, data) {\n      const df = document.createDocumentFragment();\n      const container = document.createElement('div');\n      df.appendChild(container);\n      container.insertAdjacentHTML(`afterbegin`, `<${name} ${data}></${name}>`);\n      return container.firstElementChild;\n    }\n\n    function toDOM(str) {\n      const f = (new DOMParser).parseFromString(\n          `<template>${str}</template>`,\n          \"text/html\"\n        ).head.firstElementChild.content;\n      f.normalize();\n      return f;\n    }\n\n    async function becomesTrue(check = () => true) {\n      return new Promise(async res => {\n        while(true) {\n          await sleep(47);\n          if ( check() ) break;\n        }\n        res();\n      });\n    }\n\n    async function sleep(ms) {\n      return new Promise(res => setTimeout(res, ms));\n    }\n\n    function isIterable(y) {\n      if ( y === null ) return false;\n      return y[Symbol.iterator] instanceof Function;\n    }\n\n    function isUnset(x) {\n      return x === undefined || x === null;\n    }\n\n    function say(mode, ...stuff) {\n      (DEBUG || mode === 'error' || mode.endsWith('!')) && MOBILE && alert(`${mode}: ${stuff.join('\\n')}`);\n      (DEBUG || mode === 'error' || mode.endsWith('!')) && console[mode.replace('!','')](...stuff);\n    }\n\n    function isMobile() {\n\t\t\tlet check = false;\n\t\t\t(function(a){if(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);\n\t\t\treturn check;\n    }\n}\n\n\n//# sourceURL=webpack://bang.html/./src/cat.bang.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bang.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "bang.html:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = globalThis["webpackChunkbang_html"] = globalThis["webpackChunkbang_html"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/cat.bang.js");
/******/ 	
/******/ })()
;
